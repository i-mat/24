[ { "title": "Enable Google Page Views", "url": "/24/posts/enable-google-pv/", "categories": "Blogging, Tutorial", "tags": "google analytics, pageviews", "date": "2021-01-04 07:32:00 +0800", "snippet": "This post is to enable Page Views on the Chirpy theme based blog that you just built. This requires technical knowledge and it’s recommended to keep the google_analytics.pv.* empty unless you have a good reason. If your website has low traffic, the page views count would discourage you to write more blogs. With that said, let’s start with the setup.Set up Google AnalyticsCreate GA account and propertyFirst, you need to set up your account on Google analytics. While you create your account, you must create your first Property as well. Head to https://analytics.google.com/ and click on Start Measuring Enter your desired Account Name and choose the desired checkboxes Enter your desired Property Name. This is the name of the tracker project that appears on your Google Analytics dashboard Enter the required information About your business Hit Create and accept any license popup to set up your Google Analytics account and create your propertyCreate Data StreamWith your property created, you now need to set up Data Stream to track your blog traffic. After you signup, the prompt should automatically take you to create your first Data Stream. If not, follow these steps: Go to Admin on the left column Select the desired property from the drop-down on the second column Click on Data Streams Add a stream and click on Web Enter your blog’s URLIt should look like this:Now, click on the new data stream and grab the Measurement ID. It should look something like G-V6XXXXXXXX. Copy this to your _config.yml filegoogle_analytics: id: &#39;G-V6XXXXXXX&#39; # fill in your Google Analytics ID # Google Analytics pageviews report settings pv: proxy_endpoint: # fill in the Google Analytics superProxy endpoint of Google App Engine cache_path: # the local PV cache data, friendly to visitors from GFW regionWhen you push these changes to your blog, you should start seeing the traffic on your Google Analytics. Play around with the Google Analytics dashboard to get familiar with the options available as it takes like 5 mins to pick up your changes. You should now be able to monitor your traffic in real time.Setup Page ViewsThere is a detailed tutorial available to set up Google Analytics superProxy. But, if you are interested to just quickly get your Chirpy-based blog display page views, follow along. These steps were tested on a Linux machine. If you are running Windows, you can use the Git bash terminal to run Unix-like commands.Setup Google App Engine Visit https://console.cloud.google.com/appengine Click on Create Application Click on Create Project Enter the name and choose the data center close to you Select Python language and Standard environment Enable billing account. Yeah, you have to link your credit card. But, you won’t be billed unless you exceed your free quota. For a simple blog, the free quota is more than sufficient. Go to your App Engine dashboard on your browser and select API &amp;amp; Services from the left navigation menu Click on Enable APIs and Services button on the top Enable the following APIs: Google Analytics API On the left, Click on OAuth Consent Screen and accept Configure Consent Screen. Select External since your blog is probably hosted for the public. Click on Publish under Publishing Status Click on Credentials on the left and create a new OAuth Client IDs credential. Make sure to add an entry under Authorized redirect URIs that matches: https://&amp;lt;project-id&amp;gt;.&amp;lt;region&amp;gt;.r.appspot.com/admin/auth Note down the Your Client ID and Your Client Secret. You’ll need this in the next section. Download and install the cloud SDK for your platform: https://cloud.google.com/sdk/docs/quickstart Run the following commands: [root@bc96abf71ef8 /]# gcloud init~snip~Go to the following link in your browser: https://accounts.google.com/o/oauth2/auth?response_type=code&amp;amp;client_id=XYZ.apps.googleusercontent.com&amp;amp;redirect_uri=ABCDEFGEnter verification code: &amp;lt;VERIFICATION CODE THAT YOU GET AFTER YOU VISIT AND AUTHENTICATE FROM THE ABOVE LINK&amp;gt;You are logged in as: [blah_blah@gmail.com].Pick cloud project to use:[1] chirpy-test-300716[2] Create a new projectPlease enter numeric choice or text value (must exactly match listitem): 1[root@bc96abf71ef8 /]# gcloud info# Your selected project info should be displayed here Setup Google Analytics superProxy Clone the Google Analytics superProxy project on Github: https://github.com/googleanalytics/google-analytics-super-proxy to your local. Remove the first 2 lines in the src/app.yaml file: - application: your-project-id- version: 1 In src/config.py, add the OAUTH_CLIENT_ID and OAUTH_CLIENT_SECRET that you gathered from your App Engine Dashboard. Enter any random key for XSRF_KEY, your config.py should look similar to this #!/usr/bin/python2.7__author__ = &#39;pete.frisella@gmail.com (Pete Frisella)&#39;# OAuth 2.0 Client SettingsAUTH_CONFIG = { &#39;OAUTH_CLIENT_ID&#39;: &#39;YOUR_CLIENT_ID&#39;, &#39;OAUTH_CLIENT_SECRET&#39;: &#39;YOUR_CLIENT_SECRET&#39;, &#39;OAUTH_REDIRECT_URI&#39;: &#39;%s%s&#39; % ( &#39;https://chirpy-test-XXXXXX.ue.r.appspot.com&#39;, &#39;/admin/auth&#39; )}# XSRF SettingsXSRF_KEY = &#39;OnceUponATimeThereLivedALegend&#39; Tip: You can configure a custom domain instead of https://PROJECT_ID.REGION_ID.r.appspot.com. But, for the sake of keeping it simple, we will be using the Google provided default URL. From inside the src/ directory, deploy the app [root@bc96abf71ef8 src]# gcloud app deployServices to deploy:descriptor: [/tmp/google-analytics-super-proxy/src/app.yaml]source: [/tmp/google-analytics-super-proxy/src]target project: [chirpy-test-XXXX]target service: [default]target version: [VESRION_NUM]target url: [https://chirpy-test-XXXX.ue.r.appspot.com]Do you want to continue (Y/n)? YBeginning deployment of service [default]...╔════════════════════════════════════════════════════════════╗╠═ Uploading 1 file to Google Cloud Storage ═╣╚════════════════════════════════════════════════════════════╝File upload done.Updating service [default]...done.Setting traffic split for service [default]...done.Deployed service [default] to [https://chirpy-test-XXXX.ue.r.appspot.com]You can stream logs from the command line by running:$ gcloud app logs tail -s defaultTo view your application in the web browser run:$ gcloud app browse Visit the deployed service. Add a /admin to the end of the URL. Click on Authorize Users and make sure to add yourself as a managed user. If you get any errors, please Google it. The errors are self-explanatory and should be easy to fix. If everything went good, you’ll get this screen:Create Google Analytics QueryHead to https://PROJECT_ID.REGION_ID.r.appspot.com/admin and create a query after verifying the account. GA Core Reporting API query request can be created in Query Explorer.The query parameters are as follows: start-date: fill in the first day of blog posting end-date: fill in today (this is a parameter supported by GA Report, which means that it will always end according to the current query date) metrics: select ga:pageviews dimensions: select ga:pagePathIn order to reduce the returned results and reduce the network bandwidth, we add custom filtering rules 1: filters: fill in ga:pagePath=~^/posts/.*/$;ga:pagePath!@=. Among them, ; means using logical AND to concatenate two rules. If the site.baseurl is specified, change the first filtering rule to ga:pagePath=~^/BASE_URL/posts/.*/$, where BASE_URL is the value of site.baseurl. After Run Query, copy the generated contents of API Query URI at the bottom of the page and fill in the Encoded URI for the query of SuperProxy on GAE.After the query is saved on GAE, a Public Endpoint (public access address) will be generated, and we will get the query result in JSON format when accessing it. Finally, click Enable Endpoint in Public Request Endpoint to make the query effective, and click Start Scheduling in Scheduling to start the scheduled task.Configure Chirpy to Display Page ViewOnce all the hard part is done, it is very easy to enable the Page View on Chirpy theme. Your superProxy dashboard should look something like below and you can grab the required values.Update the _config.yml file of Chirpy project with the values from your dashboard, to look similar to the following:google_analytics: id: &#39;G-V6XXXXXXX&#39; # fill in your Google Analytics ID pv: proxy_endpoint: &#39;https://PROJECT_ID.REGION_ID.r.appspot.com/query?id=&amp;lt;ID FROM SUPER PROXY&amp;gt;&#39; cache_path: # the local PV cache data, friendly to visitors from GFW regionNow, you should see the Page View enabled on your blog.Reference Google Analytics Core Reporting API: Filters &amp;#8617; " }, { "title": "Dear Deer", "url": "/24/posts/deer/", "categories": "Life, Girl", "tags": "deer", "date": "2020-02-09 11:33:00 +0800", "snippet": "璐：  鹿，今天是2020年2月9号，这是我们在一起的第1228天。初见牵手  记得之前你还问过我，咱俩什么时候算是确定关系了，我当时犹豫了一下，努力回忆暑假期间我们通宵通语音电话的时间，努力回忆你从图书馆三楼搬来六楼的时间，最终还是把我们的起点算在了2016年9月30日，那天，我们牵了手。步行从顺达广场回来，我们俩都很害羞，互相虽已明了心思，却依旧不敢对视。我低头看了眼你的手，鼓足了勇气，甚至都没有通知你一下，便用我的手握住了你的手，“哇，好软的手”，我心里一面是欣喜，一面是更加强烈的害羞感，握着你的手，我也害羞地没有看向你。可以感觉到，你愣了以下，嗔怒着说：“马滔，你挺厉害啊！”嗯，这么看，我还真是挺厉害的，班上那么多同学爱慕着你，而偏偏是我牵起了你的手，是我在等你，还是你在等我，总之很幸运，我们握住了彼此的手。一路上，我们都没有撒手，自私的我还愚蠢地问你是第一次谈恋爱么，你在反问我同样的问题之后给了我肯定的回答，那一刻我满心欢喜，感到无限的幸运。亲吻  迈出了第一步之后，便是十一长假了，我们当时都需要为彼此的未来奋斗，那时纯洁的我们也只学会了牵手，我们牵着手往来于图书馆和食堂。十月六号恰巧是我的生日，我们抱拥在操场上，你说出了你的生日礼物–你的初吻，说完你便害羞的低下了头，即便灯光昏暗，却依旧感觉到你红了的脸颊。我很意外你的生日礼物，却也对你的这份生日礼物期待许久，你的话音刚落，我便像是得到了你的圣旨般，迫不及待地想要与你拥吻。我们选在了操场上光线暗、人流小的角落，我捧起了你的脸，在对视中，我们嘴唇逐渐靠近，眼神逐渐迷离，我们第一次靠的那么近。我们的嘴唇靠在了一起，我们感受着彼此的柔软，甚至忘记了呼吸，窒息的我灵机一动，便伸出了舌头，侵入了你的口腔，那一刻我像是开辟了新的天地，舌头不停地在你的嘴里搅动着，你也配合着吮吸着我的舌头，随后你有将你的舌头伸进我嘴里，“好柔软”，我的内心说不出的满足，我们持续着互相吮吸着，最后结果便是满嘴的口水。虽然我们彼此都是第一次接吻，但我们第一次便掌握了高阶的舌吻，我们还真是很适合谈恋爱呢！！！像是潘多拉的魔盒，从那之后，我们便一发不可收拾，随处接吻，随处牵手，去食堂的沿路，都是我们接吻的剪影。争执  虽然我们在一起的三年半时间里，多说都是甜蜜期，我们中间却也夹着着很多的挣扎与纠结。那是我第一次看见你哭，原来是因为我的那句“只愿一生爱一人”，你说我们很难在一起，你说你并不是很相信爱情，那是的我完全无法理解你，那时的我没有很了解你，幼稚到觉得你在开玩笑。手足无措的我只能帮你擦拭泪水，激励我们彼此努力学习。现在已经在一起三年半了，你会相信我最初的那句幼稚的话么，很幸运，我依旧牵着你的手。  前一天晚上你还问我什么时候生气过，我在这儿用文字说出来吧。当年你打算弃考高数，坦白说，你是我生活圈中最聪明的女孩子（虽然我接触的不多），我的几个姐姐虽然很用工，最好的也只是读了专科，所以不论是当时还是现在，我对你真的很有信心，所以你说你弃考，我当时很生气，你也看到了，我那会儿也哭了。后来异地的两年时间内我们又为未来的路纠结过，挣扎过，正如大家所认同的，包括我和孟月在内的人都说过你很适合打交道，你活泼的性格，敏捷的思维，总能给大家带来欢笑，大家都会很愿意帮助你。这种感觉就是当时一同爬华山的你，我们一路的欢声笑语，不都是因为你么，所以，你知道的，我那会儿便喜欢了你，你的开朗，你的活泼，你的幽默，你的美丽，你的笑容等等，都深深地吸引着我。你的美好远超出你对自己的评估，现在我都很庆幸，你选择牵着我的手。旅行  三年的时间里，我们走过了很多地方，先是在哈尔滨，你陪着我迎接了金榜题名的喜悦，陪着我游览了中央大街的繁华，陪着我探寻了松花江的寒冰，我们还在冰雪大世界，一起玩陀螺，赏冰雕。从哈尔滨回到了扬州，我们继续着我们游玩的步伐，每天下午我们一同骑着自行车向市区驶去，绝味的鸭心，潘师傅炸鸡，刘佘记的面馆，驴肉火烧……扬州的很多小吃我们都反复地品尝过，你说你不喜欢扬州，可我们都会一直珍藏着扬州的角角落落，不是么，那儿有着我们的点点滴滴。毕业时，手头局促的我只能带着你乘着普通列车出去玩，先是去了十堰，之后去了恩施大峡谷，最后是到了重庆，我们在山谷间呼喊，我们在洪崖洞留恋，我们游历了大好河山，我们穿梭于城市繁华，而这些都因为你的相伴，而趣味横生，精彩纷呈。不懂情趣的我一直是你口中“无趣的人”，一路是我负责导航，你负责活泼，我负责傻笑，你负责幽默，那会儿，真的是太美好了。后来去到你家，又玩了大小荔波，在大峡谷玩了漂流，今年年初，我们有去到了张家界，这或许是旅程中最不如意的一次，往返的折腾，却只是看到了雾霭，但我一直记着那三只小狗追着你奔跑的画面，可爱如你，依旧未变。未完待续…  三年半的时间里，我们起了不少的争执，起初我的脾气很臭，我从一开始的倔强，后来也逐渐懂得去向你主动道歉了，当然，很多次的表现都差强人意，我也知道，作为男朋友的我做的还远低于平均水准，谢谢我的鹿，包容我的榆木脑袋三年之久。三年半的甜蜜，远甚争执，我们有着相互的牵挂，有着彼此的陪伴，我们互相分享的自己的趣事，我们也共同享受思绪的碰撞。期待着，未来还有很多的三年半，我们还有那么多的美好要经历，我们兴许也有很多磕绊要经历，但也希望无论多少个三年半之后，我们依旧四处游玩，我依旧傻笑，你依旧活泼。  谢谢，亲爱的你，跟我一起。  拜托，亲爱的你，跟我一起。" }, { "title": "Jekyll", "url": "/24/posts/jekyll/", "categories": "Tools", "tags": "jekyll", "date": "2020-02-06 11:33:00 +0800", "snippet": "运行环境 Windows 10 chocolatey步骤cinst ruby --version=2.6.5.1 # install rubycinst msys2 --params &quot;/NoUpdate&quot; # install msys2 without system updateUpdate-SessionEnvironment / refreshenv # refresh environment varsridk install 2 3 # use ruby&#39;s ridk to update the system and install development toolchaingem install jekyll # install jekyllgem install bundler # install bundlerbundle installbundle exec jekyll serve注意 执行 ridk install 2 3 时，更改源： 查找Ruby安装目录下的msys64\\etc\\pacman.d，编辑更新源：Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/i686 加入mirrorlist.mingw32首位Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/x86_64 加入mirrorlist.mingw64首位Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/msys/$arch 加入mirrorlist.msys首位 更新gem 源：gem sources --add https://mirrors.tuna.tsinghua.edu.cn/rubygems/ --remove https://rubygems.org/" }, { "title": "Chocolatey", "url": "/24/posts/chocolatey/", "categories": "Tools", "tags": "chocolatey", "date": "2019-11-11 11:33:00 +0800", "snippet": "安装choco要求：Windows 7+ / Windows Server 2003+以管理员权限运行cmd.exc或powershell.execmd运行：@&quot;%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe&quot; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString(&#39;https://chocolatey.org/install.ps1&#39;))&quot; &amp;amp;&amp;amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin&quot;安装完成，运行choco 或 choco -?检查一下是否安装正确。用choco安装软件最好还是用管理员权限运行cmd.exechoco install &amp;lt;packagename&amp;gt; -ycinst &amp;lt;packagename&amp;gt; -y安装包的搜索社区Chocolatey Gallery Packages其他用法：choco install jdk8 googlechrome vscode 7zip //一次安装多个软件包choco install nodejs.install --version 0.10.35 //安装指定版本choco install dev-package.config //安装dev-package.config文件内描述的所有软件包dev-package.config：&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;packages&amp;gt; &amp;lt;package id=&quot;jdk8&quot; /&amp;gt; &amp;lt;package id=&quot;googlechrome&quot; version=&quot;71.0.3578.98&quot; /&amp;gt; &amp;lt;package id=&quot;vscode&quot; /&amp;gt; &amp;lt;package id=&quot;7zip&quot; /&amp;gt; &amp;lt;/packages&amp;gt;文件名称随意，但是扩展名必须是.config。通过.config的方式，就可以配置一个团队统一的开发环境，软件和版本都可以统一。这样可以为开发带来很多好处，避免由于开发环境不一样引起的各种不同错误。常用命令Command Official choco list -li 查看本地安装的软件 choco search nodejs 查找安装包 choco outdated 检查是否有旧版本软件 choco list -l --idonly &amp;gt; choco.txt 导出已安装的软件列表" }, { "title": "Find Job", "url": "/24/posts/find-job/", "categories": "Job, find job", "tags": "find job", "date": "2019-09-10 11:33:00 +0800", "snippet": "招聘会链接 哈工大本部 哈工大深圳 华南理工 中山大学" }, { "title": "Basic Knowledge", "url": "/24/posts/BasicKnowldege/", "categories": "C++, Basic", "tags": "c++", "date": "2019-09-05 11:33:00 +0800", "snippet": "C++特性 封装：隐藏实现细节，使得代码模块化 继承：使用现有类的所有功能，进行功能拓展。从一般到特殊的过程，称为“子类”和“父类”。 多态：将父对象设置成为和一个或多个他的子对象相等的技术。允许将子类类型的指针赋值给父类类型的指针。将父类暴露给用户子类隐藏，子类指针转化成父类指针进行返回，可实现程序的简易替换，背后的运作原理通过子类进行切换。 上述特性最终目的是实现一个接口的复用性 多态多态的分类 静态多态（编译时候 - 早绑定） 函数重载 解释：一词多义，通过上下文来确定同名函数的重载版本 应用场景：上下文的关键：参数个数、参数类型，参数顺序（与返回值、参数名 无关），三个中至少有一个不同 多个功能类似的函数，可以共用一个函数名 e.g. print(int, chr), print(int, int) 函数模板 解释：将使用多的场景的抽象为泛型 应用场景：仅仅支持，参数个数相同且参数类型不同的情况 e.g. print(T, T) 仅仅单个类型（比重载的抽象程度更高） 动态多态（运行时候 - 晚绑定） 添加virtual关键字，虚函数实现 多态的实现#include &amp;lt;iostream&amp;gt;class Person{public: virtual void BuyTicket(int) { cout &amp;lt;&amp;lt; &quot;Adult need Full Fare!&quot; &amp;lt;&amp;lt; endl; }};class Child : public Person{public: virtual void BuyTicket(int) { cout &amp;lt;&amp;lt; &quot;Child Free!&quot; &amp;lt;&amp;lt; endl; }};void fun(Person&amp;amp; obj){ obj.BuyTicket(1); }int main(void){ Person p; Child c; fun(p); fun(c); return 0;} Output Adult need Full Fare! Child Free! Hint 只有类的成员函数才能说明为虚函数 静态成员函数不能是虚函数 内联函数不能为虚函数 构造函数不能是虚函数 析构函数可以是虚函数，而且通常声明为虚函数 C++与C的区别 C 是面向过程的语言C++是面向对象的语言 C 中函数不能进行重载C++函数可以重载 C 函数的参数如果没有写void 即是可变参数。如C 中int sum()可接收任意参数;而C++中int sum()则表示输入参数为空 C 中struct中不能有函数C++中可以有函数 C++中try/catch/throw异常处理机制取代了C 中的setjmp()和longjmp()函数。 C++中，仍然支持malloc()和free()来分配和释放内存，同时增加了new和delete来管理内存。malloc/free和new/delete区别 malloc和free都是C/C++语言的标准库函数，new/delete是C++的运算符。 new 在申请内存时会自动根据类型计算所需字节数，而malloc则需我们自己输入申请内存空间的字节数 对于非内部数据类型，new在申请内存后会在该申请的内存上调用构造函数，delete在释放内存前会调用对象的析构函数，而malloc和free只申请和释放内存。C++存储 栈：编译器自动分配和清除，局部变量和函数参数 堆：由 malloc 等分配的内存块 自由存储区：由 new 分配的内存块，程序结束后，系统可以自动回收内存，与堆类似 全局/静态存储区：全局变量和静态变量 常量：放置常量，不允许修改Static变量 static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用 static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值 static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝extern &quot;C&quot; 的修饰作用 被extern &quot;C&quot;修饰的变量和函数是按照C 语言方式编译和连接的 extern &quot;C&quot;的作用是让C++ 编译器将extern &quot;C&quot;声明的代码当作C 语言代码处理，可以避免C++因符号修饰导致代码不能和C 语言库中的符号进行链接。智能指针 目的：管理堆内存，利用对象离开作用域自动析构的特性，将释放内存的操作托管给一个对象。 引用计数（shared_ptr）： 基本思想：对被管理的资源进行引用计数，当一个shared_ptr 对象要共享这个资源的时候，该资源的引用计数加1，当这个对象生命期结束的时候，再把该引用计数减少1。这样当最后一个引用它的对象被释放的时候，资源的引用计数减少到0，此时释放该资源。 作为函数参数：传值则引用计数加1，传引用则引用计数不变 作为函数返回值：如果返回值作为右值进行拷贝，则引用计数加1，否则不变 weak_ptr是为了解决循环引用的问题，当两个对象互相引用时，计数无法降为0，weak_ptr不改变计数。深拷贝和浅拷贝 浅拷贝时一般调用的是默认构造函数，拷贝完指向同一块存储空间 深拷贝时调用自定义的构造函数，指向其他存储空间，对象中包含指针时用深拷贝内联函数与宏定义的区别 使用场景：函数简短，调用次数多。 内联函数和宏定义区别： 内联函数在编译时展开，而宏在预编译时展开 在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。 内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。 宏不是函数，而inline 是函数 什么是RTTI(Run-time type identification) 概念：运行时类型识别 作用：C++在运行时不能更改数据类型，为了满足这一要求，添加了RTTI机制 typeid和dynamic_cast：通过typeid(a).name()可知道变量a的类型结构体和联合体的区别 内存上：struct 的内存大小为所有成员变量所占内存之和（对齐原则），union 的内存大小为最长成员变量的内存大小。 成员变量上：struct 各个成员变量按照被声明的顺序依次存储，第一个成员变量的地址与整个结构体的相同，成员独自占有内存空间，赋值互不影响；union 的所有成员变量共用同一段内存，某一变量的改变会覆盖处于内存起始位置的变量值，变量之间相互影响。STL中实现了哪些排序算法 函数名 定义 sort 对给定区间所有元素进行排序（不稳定） stable_sort 对给定区间所有元素进行稳定排序 partial_sort 对给定区间所有元素部分排序 partial_sort_copy 对给定区间复制并排序 nth_element 找出给定区间的某个位置对应的元素 is_sorted 判断一个区间是否已经排好序 partition 使得符合某个条件的元素放在前面 stable_partition 相对稳定的使得符合某个条件的元素放在前面 各种排序方法的性能 排序法 平均时间复杂度 最好情况 最坏情况 空间复杂度 稳定度 插入排序 O(\\(n^{2}\\)) O(\\(n\\)) O(\\(n^{2}\\)) O(\\(1\\)) 稳定 希尔排序 O(\\(n^{1.3}\\)) O(\\(n\\)) O(\\(n^{2}\\)) O(\\(1\\)) 不稳定 选择排序 O(\\(n^{2}\\)) O(\\(n^{2}\\)) O(\\(n^{2}\\)) O(\\(1\\)) 不稳定 堆排序 O(\\(nlog_{2}n\\)) O(\\(nlog_{2}n\\)) O(\\(nlog_{2}n\\)) O(\\(1\\)) 不稳定 冒泡排序 O(\\(n^{2}\\)) O(\\(n\\)) O(\\(n^{2}\\)) O(\\(1\\)) 稳定 快速排序 O(\\(nlog_{2}n\\)) O(\\(nlog_{2}n\\)) O(\\(n^{2}\\)) O(\\(nlog_{2}n\\)) 不稳定 归并排序 O(\\(nlog_{2}n\\)) O(\\(nlog_{2}n\\)) O(\\(nlog_{2}n\\)) O(\\(n\\)) 稳定 二叉树排序 O(\\(n^{2}\\)) O(\\(n^{2}\\)) O(\\(nlog_{2}n\\)) O(\\(n\\)) 不稳定 C++的数据类型 1 字节 = 8 位 C++语言规定一个int 至少和一个short 一样大，一个long 至少和一个int 一样大，一个long long至少和一个long 一样大。 32位或64位系统下int的长度为4字节，最小可访问单位为 1 字节 类型 含义 最小尺寸 bool 布尔类型 未定义 char 字符 8 位 wchar_t 宽字符 16 位 short 短整型 16 位 int 整型 16 位 long 长整型 32 位 long long 长整型 64 位 float 单精度浮点数 6 位有效数字 double 双精度浮点数 10 位有效数字 Const 常量的状态 char * const cp ：cp is a const pointer to char const char * p：p is a pointer to const charC++11的特性 关键词及新语法：auto 关键字、nullptr 关键字、基于范围的for 语句 STL 容器：array、forward_list、unordered_map、unordered_set、 多线程：thread、atomic、condition_variable、 智能指针内存管理：shared_ptr、weak_ptr 其他：funciton、bind 封装可执行对象、lamda 表达式、move 等。 新的整型long long/unsigned long long(长度不小于64 位) final 和override 控制， final 用来限制基类虚函数的对应的派生类不能重写该虚函数，从而避免了某些接口被重写覆盖；override 则指定了函数必须重载基类的虚函数，否则编译通不过，这就避免了某些输入名或者原型不匹配等错误的发生。 默认的模板参数，C++11 中模板和函数一样，支持默认参数。 在传统C++ 的编译器中，&amp;gt;&amp;gt;一律被当做右移运算符来进行处理。C++11 开始，连续的右尖括号将变得合法，并且能够顺利通过编译。内联函数、构造函数、静态成员函数可以是虚函数么首先虚函数是针对对象而言，在运行时候才进行动态联编的。 内联函数是在编译阶段进行展开，inline 关键字作为提示符告诉编译器此函数作为内联函数希望在编译阶段展开，但是，编译器并不一定要展开。所以可以声明为虚函数。（这个问题有争执，很多帖子都说在编译器展开这个属性和虚函数冲突了，是不可以的，牛客网上有一个说是不一定要展开，但是没有一个固定的标准。） 构造函数无法是虚函数，因为调用虚函数需要虚函数表指针，而在执行构造函数之前是没有虚函数表指针的。 静态成员函数不可以是虚函数。静态函数是属于类的，不属于对象本身，自然无法有自己的虚函数表指针。4种类型转换 static_cast&amp;lt; type-id &amp;gt;( expression ) 用于数值类型之间的转换，也可以用于指针之间的转换，编译时已经确定好，效率高，但需要保证其安全性。 指针要先转换成void 才能继续往下转换。 在基类和派生类之间进行转换（必须有继承关系的两个类） 子类对象可以转为基类对象(安全)，基类对象不能转为子类对象(可以转换，但不安全，dynamic_cast 可以实现安全的向下转换)。 static_cast 不能转换掉expression 的const、volatile、或者__unaligned 属性 dynamic_cast &amp;lt; type-id&amp;gt; ( expression ) 将父类对象的指针转化为子类对象的指针或引用 dynamic_cast 只用于含有虚函数的类 先检查是否能转换成功，能成功则转换，不能返回0类的指针或引用。 const_cast &amp;lt; type-id&amp;gt; ( expression ) 这个转换类型操纵传递对象的const 属性，或者是设置或者是移除。 reinterpret_cast &amp;lt; type-id&amp;gt; ( expression ) 用在任意指针类型之间的转换；以及指针与足够大的整数类型之间的转换，从整数到指针，无视大小。 STL中常用容器的初始化 Vector vector&amp;lt;int&amp;gt; first;vector&amp;lt;int&amp;gt; second (4,100);vector&amp;lt;int&amp;gt; third (second.begin(),second.end()); vector&amp;lt;int&amp;gt; fourth (third);int myints[] = {16,2,77,29}; vector&amp;lt;int&amp;gt; fifth (myints, myints + sizeof(myints) / sizeof(int) ); List list&amp;lt;int&amp;gt; first; list&amp;lt;int&amp;gt; second (4,100); list&amp;lt;int&amp;gt; third (second.begin(),second.end()); list&amp;lt;int&amp;gt; fourth (third); int myints[] = {16,2,77,29}; list&amp;lt;int&amp;gt; fifth (myints, myints + sizeof(myints) / sizeof(int) ); Deque deque&amp;lt;int&amp;gt; first; deque&amp;lt;int&amp;gt; second (4,100); deque&amp;lt;int&amp;gt; third (second.begin(),second.end()); deque&amp;lt;int&amp;gt; fourth (third); int myints[] = {16,2,77,29}; deque&amp;lt;int&amp;gt; fifth (myints, myints + sizeof(myints) / sizeof(int) ); 二维数组的申明vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; matrix (val, vector&amp;lt;int&amp;gt; (val, 0)); matrix.size(); matrix[0].size();STL知识框架图" }, { "title": "BinaryTree Travel", "url": "/24/posts/BinaryTree-Travel/", "categories": "C++, Basic", "tags": "c++", "date": "2019-08-24 11:33:00 +0800", "snippet": "参考遍历void preorderTraversalNew(TreeNode *root, vector&amp;lt;int&amp;gt; &amp;amp;path){ stack&amp;lt; pair&amp;lt;TreeNode *, bool&amp;gt; &amp;gt; s; s.push(make_pair(root, false)); bool visited; while(!s.empty()) { root = s.top().first; visited = s.top().second; s.pop(); if(root == NULL) continue; if(visited) { path.push_back(root-&amp;gt;val); } else { s.push(make_pair(root-&amp;gt;right, false)); s.push(make_pair(root-&amp;gt;left, false)); s.push(make_pair(root, true)); } }} 将else中的三行代码交换顺序，就可以实现二叉树的不同遍历方式前序遍历简化版本void preorderTraversalNew(TreeNode *root, vector&amp;lt;int&amp;gt; &amp;amp;path){ stack&amp;lt;TreeNode *&amp;gt; s; s.push(root); while(!s.empty()) { root = s.top(); s.pop(); if(root == NULL) { continue; } else { path.push_back(root-&amp;gt;val); s.push(root-&amp;gt;right); s.push(root-&amp;gt;left); } }}" }, { "title": "Mask R-CNN", "url": "/24/posts/Mask-RCNN/", "categories": "Algo, Image Processing", "tags": "RCNN, Mask-RCNN", "date": "2019-08-21 11:33:00 +0800", "snippet": "参考下面会介绍基于ResNet50的Mask RCNN网络，其中会涉及到RPN、FPN、ROIAlign以及分类、回归使用的损失函数等介绍时所采用的MaskRCNN源码（python版本）来源于GitHub 下面的介绍都是基于这部分源码进行的（少数地方会和原始论文中有差别，不过不影响整个网络的理解）整体框架结构Global Logic Graph分解各个节点ResNet50网络简单介绍ResNet50网络主要用来提取图片的特征。MASKRCNN网络虽然对于输入图片的大小没有要求，但是在代码中存在IMAGE_MIN_DIM和IMAGE_MAX_DIM两个参数的定义，会将图片统一成设定的大小。设定的规则这里主要介绍两种常用的方式： squre：先将图片较短边按照IMAGE_MIN_DIM进行等比例缩放，再将图片以零像素填充到IMAGE_MAX_DIM大小 crop：同样，先将图片较短边按照IMAGE_MIN_DIM进行等比例缩放，再从图片中随机剪裁一个IMAGE_MIN_DIM大小的子图片作为输入图片这里，基于squre这种方式介绍，即将参数IMAGE_MAX_DIM设定为1024，因此，网络的输入图片大小就是1024*1024。ResNet50网络比较简单，主要包括卷积、BN、RELU三步提取特征的操作，其中： C1：256*256*64表示特征图的大小为256*256，特征图的个数是64个 C2：256*256*256表示特征图的大小为256*256，共有256个特征图 C3：128*128*512表示特征图的大小为128*128，共有512个特征图 C4：64*64*1024表示特征图的大小为64*64，共有1024个特征图 C5：32*32*2048表示特征图的大小为32*32，共有2048个特征图C1和C2的特征图大小是一样的，所以，FPN的建立也是基于从C2到C5这四个特征层上。FPN网络的建立通过ResNet50网络，得到图片不同阶段的特征图，利用C2，C3，C4，C5建立特征图金字塔结构 将C5经过256个1*1的卷积核操作得到：32*32*256，记为P5 将P5进行步长为2的上采样得到64*64*256，再与C4经过的256个1*1卷积核操作得到的结果相加，得到64*64*256，记为P4 将P4进行步长为2的上采样得到128*128*256，再与C3经过的256个1*1卷积核操作得到的结果相加，得到128*128*256，记为P3 将P3进行步长为2的上采样得到256*256*256，再与C2经过的256个1*1卷积核操作得到的结果相加，得到256*256*256，记为P2 将P5进行步长为2的最大池化操作得到：16*16*256，记为P6结合从P2到P6特征图的大小，如果原图大小1024*1024,那各个特征图对应到原图的步长依次为[P2,P3,P4,P5,P6]=&amp;gt;[4,8,16,32,64]Anchor锚框生成规则基于上一步得到的特征图[P2,P3,P4,P5,P6],介绍下MASKRCNN网络中Anchor锚框的生成，根据源码中介绍的规则，与之前的Faster-RCNN中的生成规则有一点差别。 遍历P2到P6这五个特征层，以每个特征图上的每个像素点都生成Anchor锚框 以P2层为例，P2层的特征图大小为256*256，相对于原图的步长为4，这样P2上的每个像素点都可以生成一个基于坐标数组[0,0,3,3]即4*4面积为16大小的Anchor锚框，当然，可以设置一个比例SCALE,将这个基础的锚框放大或者缩小，比如，这里设置P2层对应的缩放比例为16，那边生成的锚框大小就是长和宽都扩大16倍，从4*4变成64*64，面积从16变成4096，当然在保证面积不变的前提下，长宽比可以变换为32*128、64*64或128*32，这样以长、宽比率RATIO=[0.5,1,2]完成了三种变换，这样一个像素点都可以生成3个Anchor锚框。在Faster-RCNN中可以将SCALE也可以设置为多个值，而在MASKRCNN中则是每一特征层只对应着一个SCALE即对应着上述所设置的16。 以P2层每个像素点位中心，对应到原图上，则可生成256*256*3(长宽三种变换)=196608个锚框 以P3层每个像素点为中心，对应到原图上，则可生成128*128*3=49152个锚框 以P4层每个像素点为中心，对应到原图上，则可生成64*64*3=12288个锚框 以P5层每个像素点为中心，对应到原图上，则生成32*32*3=3072个锚框 以P6层每个像素点为中心，对应到原图上，则生成16*16*3=768个锚框从P2到P6层一共可以在原图上生成261888个Anchor锚框生成RPN网络数据集在上一步已经生成了26188个Anchor锚框，需要借助这些Anchors建立RPN网络训练时的正类和负类，假设需要的正样本与负样本共计256个Anchor，即RPN_TRAIN_ANCHORS_PER_IMAGE这个参数所指定。源码中这步操作由以下几方面构成： 先找到所有真实框中那些同时框住了多个物体的框，并排除掉 计算每个Anchors与该图片上标注的真实框ground truth之间的IOU如果anchor box与ground truth的IoU值最大，标记为正样本，label=1如果anchor box与ground truth的IoU&amp;gt;0.7，标记为正样本，label=1如果anchor box与ground truth的IoU&amp;lt;0.3，标记为负样本，label=-1剩下的既不是正样本也不是负样本，不用于最终训练，label=0同时，保证正样本为128个，负样本为128个除了对anchor box进行标记外，另一件事情就是计算anchor box与ground truth之间的偏移量令：ground truth:标定的框也对应一个中心点位置坐标x*,y*和宽高w*,h*anchor box:中心点位置坐标x_a,y_a和宽高w_a,h_a所以，偏移量：△x=(x*-x_a)/w_a △y=(y*-y_a)/h_a△w=log(w*/w_a) △h=log(h*/h_a)这样，经过这一步，共找到128个Anchor作为正样本和128个Anchor作为负样本， 同时，保存了这256个Anchor与真实框ground truth之间的偏移量RPN网络的分类与回归 前向传播计算分类得分(概率)和坐标点偏移量RPN网络在分类和回归的时候，分别将每一层的每一个Anchor分为背景和前景两类，以及回归四个位移量，比如P2层，特征图大小为256*256，即像素点有256*256个，每个像素点有三种长宽比例变换，一共有256*256*3个Anchor，如果是分类则需要分别计算每个Anchor为前景的得分(概率)或为背景的得分(概率)，其数组可定义为[256*256*3,2]，相应的如果是偏移量的回归则数组对应着形式为[256*256*3,4]将从P2到P6的所有层进行同样的分类和回归操作，一共得到[261888,2]的分类信息和[261888,4]的回归信息。 计算RPN网络损失值反向传播更新权重在“生成RPN网络数据集”这一步，在261888个Anchors中获得了256个正负样本且与真实框的偏移量。分类：从前向传播计算得到的所有Anchors得分数组中即上面所述的[261888,2]数组中找到这256个正样本和负样本所对应的得分，利用得分与正负样本的标签计算交叉熵损失值。RPN分类使用的是基于Softmax函数的交叉熵损失函数，Softmax函数只要是将前向传播计算的得分归一化到0~1之间的概率值，同时，经过Softmax函数后，也可以保证各个分类的概率不会出现负数Softmax函数公式：其中，表示类别j经过网络前向传播计算出来的得分，表示类别j经过Softmax函数后换算得到的概率基于Softmax的交叉熵公式：其中，表示的是真实标签，表示概率，下面用代替来表示概率，看下L的求导结果：因此假设一个5分类任务，一张图像经过Softmax层后得到的概率向量p是[0.1,0.2,0.25,0.4,0.05]，真实标签y是[0,0,1,0,0]，那么损失回传时该层得到的梯度就是p-y=[0.1,0.2,-0.75,0.4,0.05]。这个梯度就指导网络在下一次forward的时候更新该层的权重参数回归：从前向传播计算得到的所有Anchors偏移量数组中即上面所述的[261888,4]数组中找到这128个正样本所在索引对应的偏移量，利用此前向传播计算得到的偏移量与正样本与真实框之间计算的偏移量计算损失值，使用的是SmoothL1LossSmoothL1函数：对应的损失函数：其中，, ，分别表示由前向传播计算的预测框的坐标值，Anchor锚框对应的坐标值，真实框对应的坐标值SmoothL1函数的求导：将预测框与真实框偏移量之间的差值带入上述公式后可得到损失函数求导后的结果，用此更新权重实现反向传播根据RPN调整生成ROI这一部分对应着总网络图中的ProposalLayer层,取出一定量的Anchors作为ROI，这个量由源码中参数POST_NMS_ROIS_TRAINING确定，假设这个参数在训练的时候设置为2000，则我们这里需要从261888个Anchors中取出2000个作为ROI首先，按照Anchors经过RPN网络前向传播计算得出的前景（或称为正样本)的得分从高到低排序，取出前2000个得分最高的Anchors，相对应的将2000个Anchors经RPN网络前向传播计算出的偏移量累加到Anchor box上得到较为准确的box坐标。Anchor Box其中，红色的A框是生成的anchor box,而蓝色的G’框就是经过RPN网络训练后得到的较精确的预测框，绿色的G是ground truth box最后在返回前，对2000个框再进行一次非最大值抑制NMS操作用下图一个案例来对NMS算法进行简单介绍NMS如上图所示，一共有6个识别为人的框，每一个框有一个置信率。 现在需要消除多余的: 按置信率排序: 0.95, 0.9, 0.9, 0.8, 0.7, 0.7 取最大0.95的框为一个物体框 剩余5个框中，去掉与0.95框重叠率IoU大于0.6(可以另行设置)，则保留0.9, 0.8, 0.7三个框 重复上面的步骤，直到没有框了，0.9为一个框 选出来的为: 0.95, 0.9进行非最大值抑制的目的主要是需要剔除掉重复的框，如果经过非最大值抑制操作后得到的ROI没有事先代码中设定的2000个，则用0填充。生成RCNN网络数据集这一部分对应着总网络图中的DetectionTargetLayer层在经过ProposalLayer层之后得到了2000个经过微调后的ROI，而在DetectionTargetLayer需要对2000个ROI做以下几步： 首先剔除掉2000个ROI中不符合条件的ROI，主要是在ProposalLayer层最后返回的时候如果不足2000个会用0填充凑足，将这些用0填充的全部排除掉，避免参与不必要的计算 DetectionTargetLayer中会用到图片中的真实框信息，所以，在使用之前同样将所有真实框中那些同时框住了多个物体的框，并排除掉 计算每个ROI与真实框之间的IOU值如果ROI与ground truth的IoU&amp;gt;0.5，标记为正样本如果ROI与ground truth的IoU&amp;lt;0.5，标记为负样本假定正样本个数只保留到100个，而负样本一般保持是正样本数的3倍，正负样本总数则就可以达到400个，这个400可有配置文件中TRAIN_ROIS_PER_IMAGE参数确定 对于每个正样本，进一步计算与其相交最大即最接近的真实框ground truth box，将这个真实框所对应的类别即class_id赋予这个正样本，这样RCNN网络就可以区分具体哪个类别 同样，计算每个正样本ROI与最接近的真实框ground truth box之间的偏移量，这RPN中的计算公式一样 RCNN网络还需要保存与每个正样本ROI最接近的真实框ground truth box的mask掩码信息，并且知道每个mask大小为参数MASK_SHAPE所指定，一般为28*28，同时知道其所属于的类别即class_id，进行保存最后DetectionTargetLayer层返回400个正、负样本，400个位移偏移量（其中300个由0填充），400个掩码mask信息（其中300个由0填充)ROI 对齐操作通过DetectionTargetLayer层，在原图上找到400个ROI，因为这些ROI可能是有各个特征层产生的Anchor，所以，现在需要将这些ROI映射回特征图上 第一步，我们需要知道每个ROI如何和特征层对应上，论文中提到的方法是利用下面的公式：\\[k=\\left[k_{0}+\\log _{2}(\\sqrt{w h} / 244)\\right]\\]对于公式而言：w，h分别表示ROI宽度和高度；k是这个RoI应属于的特征层level；是w,h=224,224时映射的level，一般取为4，即对应着P4，至于为什么使用224，一般解释为是因为这是ImageNet的标准图片大小，比如现在有一个ROI是112*112，则利用公式可以计算得到k=3，即P3层第二步，开始讨论对齐的方式当完成每个ROI能找到其对应的特征层后，就同样可以算出其对应的步长，步长只要用于解释ROI Align的原理，论文中提到的ROI Align，这个方法的思路： 使用每个ROI的长、宽除以步长，得到ROI映射到特征图上的图片大小，比如ROI为113*113，对应P3层，步长为8，则在特征图上的感兴趣区域则为14.13*14.13 如果要将特征图上的感兴趣区域对齐到7*7，则需要将14.13*14.13这个区域分成49份，每一份的大小为：2.02*2.02 再将每个2.02*2.02的小区域，平分四份，每一份取其中心点位置，而中心点位置的像素，采用双线性插值法进行计算，这样，就会得到四个点的像素值，取四个像素值中最大值作为这个小区域(即：2.02*2.02大小的区域)的像素值，如此类推，同样是49个小区域得到49个像素值，组成7*7大小的feature map以上介绍的是论文中的ROI Align方法，但是在这篇博文开头提供的代码链接中的源码并不是这样处理的。对于ROI映射到特征图上的方法是一样的，但当每个ROI找到对应的特征层厚，直接利用Crop and Resize操作，生成7*7大小的feature mapMask掩码分支则是对齐成14*14大小的feature mapRCNN网络的类别分类、回归、mask掩码分类 RCNN网络的类别分类和回归与RPN网络中的分类和回归是一样的，损失函数也都是基于Softmax交叉熵和SmoothL1Loss，只是RPN网络中只分前景(正类)、背景(负类)，而RCNN网络中的分类是要具体到某个类别(多类别分类) mask掩码分类 在ROI对齐操作中mask分支对齐成14*14大小的feature map，并且在‘生成RCNN网络数据集’操作中知道每个正样本mask掩码区域对应的class_id 前向传播：将14*14大小feature map通过反卷积变换为[28*28*num_class]，即每个类别对应一个mask区域，称之为预测mask 与‘生成RCNN网络数据集’操作中的返回的mask也是28*28，并且知道每个mask区域的真实类别class_id，称之为真实mask 通过当前得到的真实mask中的类别class_id，遍历所有的预测mask，找到class_id类别所对应的预测mask(前向传播中介绍过每个类别都有一个预测mask)，比较真实mask与预测mask每个像素点信息，用的是binary_cross_entropy二分类交叉熵损失函数 binary_cross_entropy是二分类的交叉熵，实际是多分类softmax_cross_entropy的一种特殊情况，当多分类中，类别只有两类时，即0或者1，因为28*28大小的mask中只有0和1，即是像素和不是像素。 \\[loss = - \\sum_{i=1}^n \\hat{y}_{i} \\log y_{i} +\\left(1-\\hat{y}_{i}\\right) \\log \\left(1-\\hat{y}_{i}\\right) \\\\ \\frac{\\partial \\operatorname{loss}}{\\partial y}=-\\sum_{i=1}^{n} \\frac{\\hat{y}_{i}}{y_{i}}-\\frac{1-\\hat{y}_{i}}{1-y_{i}}\\]这个是针对概率之间的损失函数，你会发现只有（预测概率）和（真实标签)是相等时，loss才为0，否则loss就是为一个正数。而且，概率相差越大，loss就越大，根据Loss值更改权重实现反向传播。" }, { "title": "Cin Cout", "url": "/24/posts/cincout/", "categories": "C++, Test", "tags": "c++", "date": "2019-08-20 11:33:00 +0800", "snippet": "输入连续数进入vectorvector&amp;lt;int&amp;gt; a;int num,i=0;int temple;cin &amp;gt;&amp;gt; num;while (i&amp;lt;num){ cin &amp;gt;&amp;gt; temple; a.push_back(temple); i++;}迭代器输出vectorfor (vector&amp;lt;int&amp;gt;::iterator it = a.begin();it != a.end();++it) cout&amp;lt;&amp;lt; *it&amp;lt;&amp;lt; &#39; &#39;;cout &amp;lt;&amp;lt; endl;输出二维vectorfor (int i = 0;i &amp;lt; res.size();i++){ for (int j = 0;j &amp;lt; res[i].size();j++) cout &amp;lt;&amp;lt; res[i][j] &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl;}cout &amp;lt;&amp;lt; endl;输入多行字符串string s;vector &amp;lt;string&amp;gt; a;int num;cin &amp;gt;&amp;gt; num;cin.ignore();while (num--){ getline(cin, s); a.push_back(s);}for (int i=0;i&amp;lt;a.size();i++) cout &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; endl;cout &amp;lt;&amp;lt; endl;数组（vector）与字符串（string）相互转化string s;char ch;int tmp;vector&amp;lt;int&amp;gt; b;vector&amp;lt;int&amp;gt; a{1,3,7,6};for (int i = 0;i &amp;lt; a.size();i++){ ch = a[i]+&#39;0&#39;; s += ch;} for (int i = 0;i &amp;lt; s.size();i++){ tmp = s[i]-&#39;0&#39;; b.push_back(tmp);}申请动态空间int *p=new int;delete p;int *p=new int(10);delete p;int *p=new int[10]; delete [] p;p=NULL;华为0731笔试题第二题找匹配的数string s;vector &amp;lt;string&amp;gt; a;vector&amp;lt;int&amp;gt; result;int num;cin &amp;gt;&amp;gt; num;cin.ignore();while (num--){ getline(cin, s); a.push_back(s);}for (int i = 0;i &amp;lt; a.size();i+=2){ a[i] += a[i];}for (int i = 0;i &amp;lt; a.size();i += 2){ if (a[i].find(a[i + 1])!=string::npos) result.push_back(1); else result.push_back(0);}for (int i = 0;i &amp;lt; result.size();i++) cout &amp;lt;&amp;lt; result[i];华为0731笔试题第一题最接近某个数的商double num = 3.14159265358979;double diff=0.5,difference;int n, m;int flag = 0;double result;int a = floor(num);int b = ceil(num);for (int i=0;i &amp;lt;= 10000 &amp;amp;&amp;amp; flag==0;i++){ for (int j = i*a;j &amp;lt;=i*b;j++) { result = abs((double)j / i - num); if (result == 0) { cout &amp;lt;&amp;lt; j &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; i; flag = 1; break; } else if (diff &amp;gt; result) { diff = result; m = j; n = i; } }}if(flag==0) cout &amp;lt;&amp;lt; m &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; n;华为0808笔试（与或非计算）#include &amp;lt;cstdio&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;stack&amp;gt;using namespace std;const int MAXN = 150;char s[MAXN];char opset[6] = { &#39;!&#39;,&#39;&amp;amp;&#39;,&#39;|&#39;,&#39;(&#39;,&#39;)&#39;,&#39;#&#39; };char prio[6][6] ={ &#39;&amp;gt;&#39;, &#39;&amp;gt;&#39;, &#39;&amp;gt;&#39;, &#39;&amp;lt;&#39;, &#39;&amp;gt;&#39;, &#39;&amp;gt;&#39;, &#39;&amp;lt;&#39;, &#39;&amp;gt;&#39;, &#39;&amp;gt;&#39;, &#39;&amp;lt;&#39;, &#39;&amp;gt;&#39;, &#39;&amp;gt;&#39;, &#39;&amp;lt;&#39;, &#39;&amp;lt;&#39;, &#39;&amp;gt;&#39;, &#39;&amp;lt;&#39;, &#39;&amp;gt;&#39;, &#39;&amp;gt;&#39;, &#39;&amp;lt;&#39;, &#39;&amp;lt;&#39;, &#39;&amp;lt;&#39;, &#39;&amp;lt;&#39;, &#39;=&#39;, &#39;&amp;gt;&#39;, &#39;&amp;gt;&#39;, &#39;&amp;gt;&#39;, &#39;&amp;gt;&#39;, &#39;&amp;lt;&#39;, &#39;&amp;gt;&#39;, &#39;&amp;gt;&#39;, &#39;&amp;lt;&#39;, &#39;&amp;lt;&#39;, &#39;&amp;lt;&#39;, &#39;&amp;lt;&#39;, &#39;&amp;gt;&#39;, &#39;=&#39;,};//找到对应运算符在 opset 数组的下标int findindex(char op){ for (int i = 0; i &amp;lt; 6; i++) { if (opset[i] == op) return i; }}char compare(char a, char b){ int x = findindex(a); int y = findindex(b); return prio[x][y];}// 计算结果int calc(int x, int y, char op){ if (op == &#39;|&#39;) return x | y; if (op == &#39;&amp;amp;&#39;) return x &amp;amp; y; return 0;}int main(){ while (cin.get(s, MAXN)) { int lens = strlen(s); s[lens] = &#39;#&#39;; // s 数组尾部存为&#39;#&#39; s[lens + 1] = &#39;\\0&#39;; int t, x, y; char op; int i = 0; stack&amp;lt;int&amp;gt;P; // 用于存储运算数，整数元素 stack&amp;lt;char&amp;gt;Q; //用于存储运算符号，字符元素 Q.push(&#39;#&#39;); //把栈底存为 &#39;#&#39; while (s[i] != &#39;#&#39; || Q.top() != &#39;#&#39;) {//当s数组读到末尾，且Q已经读到栈底，说明全部运算结束 if (s[i] == &#39;1&#39; || s[i] == &#39;0&#39;) { if (s[i] == &#39;1&#39;) t = 1; else t = 0; P.push(t); i++; } else if (s[i] != &#39; &#39;) { //由于输入的字符串包含空格，所以要空格要略过 switch (compare(Q.top(), s[i])) { case &#39;&amp;lt;&#39;: // 栈顶元素优先级低，则当前元素入栈 Q.push(s[i]); i++; break; case &#39;=&#39;: // 左右括号匹配，脱括号并接收下一字符 Q.pop(); i++; break; case &#39;&amp;gt;&#39;: // 退栈并将运算结果入栈 if (Q.top() == &#39;!&#39;) { // 栈顶元素为 ！，单目操作符 x = P.top(); P.pop(); P.push(!x); Q.pop(); } else { // 栈顶元素不是 ！双目操作符 x = P.top(); P.pop(); y = P.top(); P.pop(); op = Q.top(); Q.pop(); //计算结果并入栈 P.push(calc(x, y, op)); } break; } } } int ans = P.top(); cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; system(&quot;pause&quot;); } return 0;}网易笔试第二题// 全排序的类class full_order {public: void permute(vector&amp;lt;int&amp;gt;nums, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; ans, int begin, int end) { if (begin &amp;gt; end) { if (front_equal(nums, nums.size())) { ans.push_back(nums); return; } } else { for (int i = begin; i &amp;lt;= end; i++) { swap(nums[begin], nums[i]); permute(nums, ans, begin + 1, end); } } } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permute(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; int len = nums.size() - 1; permute(nums, ans, 0, len); return ans; } bool front_equal(vector&amp;lt;int&amp;gt; a, int num) { // 首尾两个数判断 if (a.front() &amp;gt;= a.back() + a[2]) return false; if (a.back() &amp;gt;= a.front() + a[num - 2]) return false; // 中间的数判断 for (int i = 1;i &amp;lt; (num - 1);i++) { if (a[i] &amp;gt;= a[i - 1] + a[i + 1]) return false; } return true; }};// 输入过程int num1, num2;int j;cin &amp;gt;&amp;gt; num1 &amp;gt;&amp;gt; num2;if (num2 &amp;lt; 3) return 0;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; a(num1, vector&amp;lt;int&amp;gt;(num2, 0));vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; b;for (int i = 0;i &amp;lt; num1;i++){ for (int j = 0;j &amp;lt; num2;j++) { cin &amp;gt;&amp;gt; a[i][j]; }} // 得出全排序full_order equal_before;for (int i = 0;i &amp;lt; num1;i++){ b = equal_before.permute(a[i]); if(b.size()!=0) cout &amp;lt;&amp;lt; &quot;YES&quot; &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; &quot;NO&quot; &amp;lt;&amp;lt; endl;}" }, { "title": "Lead To Offer", "url": "/24/posts/lead-to-offer/", "categories": "C++, Test", "tags": "c++", "date": "2019-08-19 11:33:00 +0800", "snippet": "3 数组-找出数组中重复的数字bool duplicate(int numbers[], int length, int* duplication){ // 判断数组不为空 if (numbers == NULL || length &amp;lt;= 0) { return false; } // 判断数值在制定范围内 for (int i = 0;i &amp;lt; length;i++) { if (numbers[i] &amp;lt; 0 || numbers[i]&amp;gt;length - 1) return false; } // 从位置0开始交换 for (int i = 0;i &amp;lt; length;i++) { while (numbers[i] != i) { if (numbers[i] == numbers[numbers[i]]) { *duplication = numbers[i]; return true; } swap(numbers[i], numbers[numbers[i]]); } } return false;}3.1 数组-不修改数组找重复数字 利用二分法进行数组分割int countRange(const int* numbers, int length, int start, int end);// 参数:// numbers: 一个整数数组// length: 数组的长度// 返回值: // 正数 - 输入有效，并且数组中存在重复的数字，返回值为重复的数字// 负数 - 输入无效，或者数组中没有重复的数字int getDuplication(const int* numbers, int length){ if(numbers == nullptr || length &amp;lt;= 0) return -1; int start = 1; int end = length - 1; while(end &amp;gt;= start) { int middle = ((end - start) &amp;gt;&amp;gt; 1) + start; int count = countRange(numbers, length, start, middle); if(end == start) { if(count &amp;gt; 1) return start; else break; } if(count &amp;gt; (middle - start + 1)) end = middle; else start = middle + 1; } return -1;}int countRange(const int* numbers, int length, int start, int end){ if(numbers == nullptr) return 0; int count = 0; for(int i = 0; i &amp;lt; length; i++) if(numbers[i] &amp;gt;= start &amp;amp;&amp;amp; numbers[i] &amp;lt;= end) ++count; return count;}3.2 找出没有重复的数字 利用位运算–异或int find(int[] arr){ int tmp = arr[0]; for(int i = 1;i &amp;lt; arr.length; i++){ tmp = tmp ^ arr[i]; } return tmp;}4 数组-二维数组中的查找 数组由左到右 和 由上到下 均为递增；查找某个数 以数组的右上角或者左下角为突破口bool fintTarget(int* matrix, int target,int row,int column){ // 判断在数的范围内 if (target&amp;lt;matrix[0][0] || target&amp;gt;matrix[row][column]) return false; int row_a = 0, column_a = column - 1; // 比右上角的数大，则到下一行，否则换到前一列 while (row_a &amp;lt; row &amp;amp;&amp;amp; column &amp;gt;= 0) { if (matrix[row_a][column_a] == target) return true; else if (matrix[row_a][column_a] &amp;gt; target) column_a--; else row_a++; } return false;}5 字符串-替换空格 双指针，一个指向末尾，一个指向拓展后的末尾// 基本方法void replaceSpace(char *str,int length) { // 判断数据不为空 if(str == NULL||length&amp;lt;=0) return; // 拓展数据长度 int true_length=0,count_blank=0; int i=0; while(str[i]!=&#39;\\0&#39;) { true_length++; if(str[i]==&#39; &#39;) count_blank++; i++; } // 计算拓展后的字符串长度，判断是否在length范围内 int new_length=true_length+2*count_blank; if(new_length&amp;gt;length) return; // 后移，替换 int a_pointer=true_length; int b_pointer=new_length; while(a_pointer&amp;gt;=0 &amp;amp;&amp;amp; a_pointer&amp;lt;b_pointer) { if(str[a_pointer]!=&#39; &#39;) { str[b_pointer]=str[a_pointer]; a_pointer--; b_pointer--; } else { a_pointer--; str[b_pointer--]=&#39;0&#39;; str[b_pointer--]=&#39;2&#39;; str[b_pointer--]=&#39;%&#39;; } } };// STL的方法int main(){ string a = &quot;a time for you&quot;; string b; for (int i = 0; i &amp;lt; a.length(); i++) { if (a[i] == &#39; &#39;) { b.push_back(&#39;%&#39;); b.push_back(&#39;2&#39;); b.push_back(&#39;0&#39;); } else b.push_back(a[i]); } for (string::iterator it = b.begin(); it != b.end(); ++it) cout &amp;lt;&amp;lt; *it; cout &amp;lt;&amp;lt; endl; system(&quot;pause&quot;); return 0;}6 链表-在链表结尾添加一个节点// 单向链表节点定义struct ListNode{ int L_value; ListNode* L_next;};// 添加节点void AddToTail(ListNode**pHead,int value){ ListNode* pNew = new ListNode(); pNew-&amp;gt;L_value = value; pNew-&amp;gt;L_next = NULL; // 判断首节点是不是空节点 if (*pHead == NULL) { *pHead = pNew; } else { ListNode* pNode = *pHead; while (pNode-&amp;gt;L_next != NULL) pNode = pNode-&amp;gt;L_next; pNode-&amp;gt;L_next = pNew; }}6.1 链表-删除某个节点void Remove(ListNode**pHead,int value){ ListNode* pNew = new ListNode(); pNew-&amp;gt;L_value = value; pNew-&amp;gt;L_next = NULL; if (*pHead == NULL||pHead==NULL) { return; } // 用来存放待删除的节点 ListNode*toBedeleted = NULL; if ((*pHead)-&amp;gt;L_value == value) { toBedeleted = *pHead; *pHead = (*pHead)-&amp;gt;L_next; } else { ListNode* pNode = (*pHead)-&amp;gt;L_next; while (pNode != NULL &amp;amp;&amp;amp; pNode-&amp;gt;L_value != value) pNode = pNode-&amp;gt;L_next; if (pNode != NULL) { toBedeleted = pNode; pNode-&amp;gt;L_next = pNode-&amp;gt;L_next-&amp;gt;L_next; } } if (toBedeleted != NULL) { delete toBedeleted; toBedeleted = NULL; }}6.2 链表-从尾到头打印链表 先进后出的情况，用栈来实现// 循环访问的方法void PrintValueReverse(ListNode*pHead){ // 声明nodes的栈 stack&amp;lt;int&amp;gt;nodes; ListNode* pNode = pHead; while (pNode != NULL) { nodes.push(pNode-&amp;gt;L_value); pNode = pNode-&amp;gt;L_next; } // 输出nodes while (nodes.empty()) { cout &amp;lt;&amp;lt; nodes.top(); nodes.pop(); }}// 递归的方法void PrintValueReverse(ListNode*pHead){ if (pHead!= NULL) { if (pHead-&amp;gt;L_next != NULL) { PrintValueReverse(pHead-&amp;gt;L_next); } cout &amp;lt;&amp;lt; pHead-&amp;gt;L_value; } }7 树-重建二叉树 参考class Solution {public: TreeNode* reConstructBinaryTree(vector&amp;lt;int&amp;gt; pre, vector&amp;lt;int&amp;gt; in) { // 检查输入的正确性 if (pre.empty() || in.empty() || pre.size() != in.size()) return NULL; return construct(pre, 0,pre.size() - 1, in,0,pre.size()-1); }public: TreeNode* construct(vector&amp;lt;int&amp;gt; pre,int ps,int pe, vector&amp;lt;int&amp;gt; in,int is,int ie) { if (ps &amp;gt; pe) return NULL; // 取前序遍历第一个是根节点 int value = pre[ps]; // 在中序中找根节点 int i = 0; while (i &amp;lt;= ie &amp;amp;&amp;amp; in[i] != value) { i++; } // 如果没有找到，则输入不合法，抛出异常 if (i &amp;gt; ie) return NULL; // 创建当前根节点，并赋值 TreeNode* FinalTree = new TreeNode(value); // 递归调用当前节点的左子树 FinalTree-&amp;gt;left = construct(pre, ps + 1, ps + i - is, in, is, i - 1); // 递归当前调用节点的右子树 FinalTree-&amp;gt;right = construct(pre, ps + i - is + 1, pe, in, i + 1, ie); return FinalTree; }};8 树-二叉树的下一个节点 如果节点有右子节点，则右子节点的最左节点是该节点的下一个节点 如果节点无右子节点，但该节点是其父节点的左子节点，则父节点是该节点的下一个节点 如果节点无右子节点，且该节点是其父节点的右子节点，则沿着父节点向上遍历，满足XXX的父节点是其该节点的下一个节点TreeNode* GetNext(TreeNode* pNode){ TreeNode* pNext = NULL; // 有右子树 if (pNode-&amp;gt;right != NULL) { if ((pNode-&amp;gt;right-&amp;gt;left) != NULL) pNext = pNode-&amp;gt;right-&amp;gt;left; else pNext = pNode-&amp;gt;right; } // 无右子树，有父节点 else if (pNode-&amp;gt;par != NULL) { TreeNode*pCurrent = pNode; TreeNode*pParent = pNode-&amp;gt;par; while (pParent != NULL &amp;amp;&amp;amp; pParent-&amp;gt;right == pCurrent) { pCurrent = pParent; pParent = pCurrent-&amp;gt;par; } pNext = pParent; } return pNext;}9 栈和队列-用两个栈实现队列 先将树压入第一个栈 将第一个栈元素pop出，push进第二个栈 第二个栈就是队列的顺序void push(int node) { int temple; while(!stack2.empty()) { temple=stack2.top(); stack2.pop(); stack1.push(temple); } stack1.push(node);}int pop() { int temple; while(!stack1.empty()) { temple=stack1.top(); stack1.pop(); stack2.push(temple); } temple=stack2.top(); stack2.pop(); return temple;}10 斐波那契数 循环方法实现计算 时间复杂度O(n) 青蛙跳台阶问题long long Fibonacci(unsigned n){ int result[2] = { 0,1 }; if (n &amp;lt; 2) return result[n]; long long fibFront = 0; long long fibBack = 1; long long fibN = 0; for (unsigned int i = 2;i &amp;lt;= n;i++) { fibN = fibFront + fibBack; fibFront = fibBack; fibBack = fibN; } return fibN;}排序-快排 指定最左端的数为 pivot 左指针找第一个大于 pivot 的数 右指针找第一个小于 pivot 的数 交换两个数 大于begin的数都在右，小于的都在左void QuickSort(vector&amp;lt;int&amp;gt; &amp;amp;a,int left,int right){ int i = left; int j = right; int pivot = a[i]; while (i &amp;lt;= j) { while (a[i] &amp;lt; pivot) { i++;} while (a[j] &amp;gt; pivot) { j--;} if (i &amp;lt;= j) { swap(a[i], a[j]); i++; j--; } } if (i &amp;lt; right) QuickSort(a, i, right); if (j &amp;gt; left) QuickSort(a, left, j);}排序-归并 递归 合并两个数组的函数 二分排序void Merge(vector&amp;lt;int&amp;gt; &amp;amp;a, int l, int m, int r){ // 获取左右部分数组的大小（实际还是原数组） int l_c = m - l + 1; int r_c = r - m; // 将数组值赋给临时数组（两个数组） int i, j, k; vector&amp;lt;int&amp;gt; L(l_c + 1); vector&amp;lt;int&amp;gt; R(r_c + 1); for (i = 0;i &amp;lt; l_c;i++) L[i] = a[l + i]; for (j = 0;j &amp;lt; r_c;j++) R[j] = a[m + 1 + j]; // 每个数组的最后一个数赋值11111111,任意数与之比较都小 L[l_c] = 11111111; R[r_c] = 11111111; // for (i = 0, j = 0, k = l;k &amp;lt;= r;k++) { if (L[i] &amp;lt; R[j]) a[k] = L[i++]; else a[k] = R[j++]; }}void MergeSort(vector&amp;lt;int&amp;gt; &amp;amp;a, int l, int r){ if (l &amp;lt; r) { int m = (l + r) / 2; MergeSort(a, l, m); MergeSort(a, m + 1, r); Merge(a, l, m, r); }}排序-堆排 原则 符合完全二叉树 父节点大于孩子节点 步骤 构建最大堆–插入构建 删除首个-&amp;gt;下面的顺次移位 void insert_p(vector&amp;lt;int&amp;gt; &amp;amp;a, int p){ while (p &amp;gt; 0) { int parent = (p - 1) / 2; if (a[parent] &amp;lt; a[p]) // if(a[parent] &amp;gt; a[p]) { swap(a[parent], a[p]); p = parent; } else break; }}void delete_max(vector&amp;lt;int&amp;gt; &amp;amp;a, int length){ int tmp = a[0]; int index = 0; // 找出最大的 // large指向已遍历的最大值 // index指向当前空缺位置 while (1) { int left = 2 * index + 1; int right = 2 * index + 2; if (left &amp;gt;= length) break; else { int large = a[left] &amp;gt; a[right] ? left : right; a[index] = a[large]; index = large; } } a[index] = a[length]; a[length] = tmp;}void HeapSort(vector&amp;lt;int&amp;gt; &amp;amp;a){ for (int i = 0;i &amp;lt; a.size();i++) insert_p(a, i); for (int i = a.size() - 1;i &amp;gt; 0;i--) delete_max(a, i);}11 查找-找出旋转数组的最小数字 二分法、双指针 中间与左、右的值都相等时，采用顺序遍历 MinInOrderint MinInOrder(vector&amp;lt;int&amp;gt; &amp;amp;a, int left, int right){ int result = a[left]; for (int i = left + 1;i &amp;lt;= right;i++) { if (result &amp;gt; a[i]) result = a[i]; } return result;}int FindMin_Rotate(vector&amp;lt;int&amp;gt; &amp;amp;a){ int left = 0; int right = a.size() - 1; int mid = 0; while (a[left] &amp;gt;= a[right]) { if (right - left == 1) { mid = right; break; } mid = (left + right) / 2; // 若left、mid、right三个指针指的数都相同，则用顺序查找 if (a[left] == a[right] &amp;amp;&amp;amp; a[left] == a[mid]) return MinInOrder(a, left, right); if (a[mid] &amp;gt;= a[left]) left = mid; else if (a[mid] &amp;lt;= a[right]) right = mid; } return a[mid]; }12 回溯法-矩阵中的路径 判断数组中是否含有相应字符串bool haspath(char* matrix, int rows, int cols,char* str){ // 判断二维数组是否合法 if (matrix == NULL || rows &amp;lt; 0 || cols &amp;lt; 0) return false; // 创建访问标志的数组,置为0/false bool* visited = new bool[rows*cols]; memset(visited, 0, rows*cols); int pathLength = 0; // 在二维数组内循环 for (int row = 0;row &amp;lt; rows;row++) { for (int col = 0;col &amp;lt; cols;col++) { if (haspathcore) return true; } } delete[] visited; return false;}bool haspathcore(char* matrix, int rows, int cols, int row, int col, char* str, int&amp;amp; pathLength, bool* visited){ // 读取到str最后，则返回true if (str[pathLength] == &#39;\\0&#39;) return true; bool haspath = false; if (row &amp;gt;= 0 &amp;amp;&amp;amp; row &amp;lt; rows &amp;amp;&amp;amp; col &amp;gt;= 0 &amp;amp;&amp;amp; col &amp;lt; cols &amp;amp;&amp;amp;matrix[row*cols + col] == str[pathLength] &amp;amp;&amp;amp; !visited[row*cols + col]) { pathLength++; visited[row*cols + col] = true; // 在其上下左右四个方向查找 haspath = haspathcore(matrix, rows, cols, row - 1, col, str, pathLength, visited) || haspathcore(matrix, rows, cols, row, col - 1, str, pathLength, visited) || haspathcore(matrix, rows, cols, row + 1, col, str, pathLength, visited) || haspathcore(matrix, rows, cols, row, col + 1, str, pathLength, visited); if (!haspath) { --pathLength; visited[row*cols + col] = false; } } return haspath;}14 动态规划-剪绳子 至少被分成2段 求各段最大乘积 动态规划 贪心算法，n&amp;gt;=5时，讨论情况 O(1)// 动态规划int max_cut(int length){ // 排除三个特殊示例 if (length &amp;lt; 2) return 0; if (length == 2) return 1; if (length == 3) return 2; // 初始化新的数组 int* arr = new int[length + 1]; arr[0] = 0; arr[1] = 1; arr[2] = 2; arr[3] = 3; int max=0; for (int i = 4;i &amp;lt;=length;i++) { max = 0; for (int j = 0;j &amp;lt; i / 2;j++) { // 寻找最大 int count = arr[j] * arr[i - j]; if (max &amp;lt; arr[i]) max = arr[i]; arr[i] = max; } } return arr[length];}// 贪心算法int max1_cut(int length){ // 排除三个特殊示例 if (length &amp;lt; 2) return 0; if (length == 2) return 1; if (length == 3) return 2; // 能够减3的次数 int count_3 = length / 3; // 余数为1时，则少减一次，4=2*2 if (length % 3 == 1) count_3--; // 能够除以2的次数 int count_2 = (length - count_3) / 2; int max = pow(3, count_3)*pow(2, count_2); return max;}15 位运算-二进制中1的个数int count_1(int n){ int count = 0; while (n) { count++; n = n &amp;amp; (n - 1); } return count;}对应剑指offer第三章-高质量的代码 规范性 书写清晰 布局合理 命名合理 完整性 完成基本功能 考虑边界条件 做好错误处理 鲁棒性 采取防御性编程 处理无效输入 16 数值的整数次方 位运算的适用范围仅仅是整数 递归算法适用负数// 位运算int pow_test(int m, int n){ int sum = 1; int temp = m; while (n) { if (n &amp;amp; 1 == 1) sum *= temp; n=n &amp;gt;&amp;gt; 1; temp *= temp; } return sum ;}// 递归double pow_try(double m, int n){ if (n == 0) return 1.0; if (n == 1) return m; double base = pow_try(m,n&amp;gt;&amp;gt;1); base *= base; if (n &amp;amp; 1 == 1) base *= m; return base; }17 打印 1-最大的n位数 难点：大数–需要将数转化为字符串18 删除连续的重复数-链表void deleteDuplication(ListNode** pHead){ if (pHead == nullptr || *pHead == nullptr) return; ListNode* pPre = nullptr; ListNode* pCur = *pHead; while (pCur != nullptr) { ListNode* pNex = pCur-&amp;gt;n_next; bool needDelete = false; if (pNex != nullptr&amp;amp;&amp;amp;pCur-&amp;gt;n_value == pNex-&amp;gt;n_value) needDelete = true; if (!needDelete) { pPre = pCur; pCur = pNex; } else { int value = pCur-&amp;gt;n_value; ListNode* pTobeDel = pCur; while (pTobeDel != nullptr&amp;amp;&amp;amp;pTobeDel-&amp;gt;n_value == value) { pNex = pTobeDel-&amp;gt;n_next; delete pTobeDel; pTobeDel = nullptr; pTobeDel = pNex; } // 若指针头就是重复，且被删除，后面无后续数字，则 if (pPre == nullptr) *pHead = pNex; else pPre-&amp;gt;n_next = pNex; pCur = pNex; } }}21 调整数组，使奇数在前，偶数在后 借鉴快排的方法 可以将(a[i] &amp;amp; 1) == 1转换成一个函数fun(n)，增强其泛化能力void changearray(vector&amp;lt;int&amp;gt; &amp;amp;a){ // int tmp = a[0]; int i = 0; int j = a.size() - 1; while (i &amp;lt;= j) { while ((a[i] &amp;amp; 1) == 1) { i++; } while ((a[j] &amp;amp; 1) == 0) { j--; } if (i &amp;lt;= j) { swap(a[i], a[j]); cout &amp;lt;&amp;lt; &quot;i is &quot; &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; &quot;j is &quot; &amp;lt;&amp;lt; a[j] &amp;lt;&amp;lt; &quot;\\n&quot;; i++; j--; } } }22 链表中倒数第K个节点 双指针 第一个指针到（k-1）时，第二个与第一个开始同步前进 增加测试样例，提高鲁棒性ListNode* FindKthNode(ListNode*pListHead, int k){ if (pListHead == NULL || k == 0) return NULL; ListNode* ANode = pListHead; ListNode* BNode = ANode; for (int i = 0;i &amp;lt; k - 1;i++) ANode = ANode-&amp;gt;n_next; while (ANode-&amp;gt;n_next) { ANode = ANode-&amp;gt;n_next; BNode = BNode-&amp;gt;n_next; } return BNode;}23 链表中环的入口节点 先判断是否有环：双指针，一快一慢，快的追上慢的，则有环 找入口：双指针，第一个比第二个多环的节点数n 24 反转链表 ListNode* ReverseList(ListNode* pHead){ // 定义三个循环节点 ListNode* pre; ListNode* curr; ListNode* follow; // 初始化 pre = pHead; curr = pHead-&amp;gt;n_next; follow = curr-&amp;gt;n_next; // 循环，每次改变一个节点的指针方向 pHead-&amp;gt;n_next = NULL; while (follow!=NULL) { curr-&amp;gt;n_next = pre; pre = curr; curr = follow; follow = follow-&amp;gt;n_next; } curr-&amp;gt;n_next = pre;}25 合并两个排序好的链表ListNode*Merge(ListNode* pHead1, ListNode* pHead2){ if (pHead1 == NULL) return pHead2; if (pHead2 == NULL) return pHead1; ListNode* MergedHead = NULL; if (pHead1-&amp;gt;n_next &amp;lt; pHead2-&amp;gt;n_next) { MergedHead = pHead1; MergedHead-&amp;gt;n_next = Merge(pHead1-&amp;gt;n_next,pHead2); } else { MergedHead = pHead2; MergedHead-&amp;gt;n_next = Merge(pHead1,pHead2-&amp;gt;n_next); } return MergedHead;}26 判断B是否是A的子结构-树 子树不单单只有两层 若树的值不是int型，则不能直接用等号判断大小bool a_include_b(BinaryTree* father, BinaryTree* son){ if (son == nullptr) return true; if (father == nullptr) return false; if (father-&amp;gt;p_value != son-&amp;gt;p_value) return false; return a_include_b(father-&amp;gt;p_left, son-&amp;gt;p_left) &amp;amp;&amp;amp; a_include_b(father-&amp;gt;p_right, son-&amp;gt;p_right);}bool SonTree(BinaryTree* father, BinaryTree* son){ bool result = false; if (father != nullptr &amp;amp;&amp;amp;son != nullptr) { if (father-&amp;gt;p_value == son-&amp;gt;p_value) result = a_include_b(father, son); if (!result) result = SonTree(father-&amp;gt;p_left, son); if(!result) result = SonTree(father-&amp;gt;p_right, son); } return result;}对应剑指offer第四章–解决面试题的思路 抽象问题具体化 画图 举例 分解让复杂问题简单化27 二叉树的镜像 树不一定必须是完全二叉树 自上而下，自左而右// 二叉树的镜像// // 树的申明struct BinaryTree{ int b_value; BinaryTree* b_left; BinaryTree* b_right;};// // 函数void MirrorBinTree(BinaryTree* pNode){ if (pNode == nullptr) return; if (pNode-&amp;gt;b_left == nullptr&amp;amp;&amp;amp;pNode-&amp;gt;b_right == nullptr) return; BinaryTree* pTemp = pNode-&amp;gt;b_left; pNode-&amp;gt;b_left = pNode-&amp;gt;b_right; pNode-&amp;gt;b_right = pTemp; if (pNode-&amp;gt;b_left) MirrorBinTree(pNode-&amp;gt;b_left); if (pNode-&amp;gt;b_right) MirrorBinTree(pNode-&amp;gt;b_right);}28 对称二叉树 判断二叉树是不是对称 如果二叉树的镜像和本身一样,则是对称二叉树 前序遍历和对称前序遍历,需要考虑空指针的情况// 对称二叉树// // 初次输入时两个root相同bool isSym(BinaryTree* root1, BinaryTree* root2){ if (root1 ==nullptr&amp;amp;&amp;amp; root2==nullptr) return true; if (root1 == nullptr|| root2 == nullptr) return false; if (root1-&amp;gt;b_value != root2-&amp;gt;b_value) return false; return isSym(root1-&amp;gt;b_left, root2-&amp;gt;b_right) &amp;amp;&amp;amp; isSym(root1-&amp;gt;b_right, root1-&amp;gt;b_left);}29 顺序打印矩阵 取左上角的元素为 start 边界条件为 col&amp;gt;2start &amp;amp;&amp;amp; row&amp;gt;2start 每次打印一圈 30 包含min函数的栈 用辅助栈实现最小栈的功能 template &amp;lt;typename T&amp;gt; class StackWithMin{public: StackWithMin() {} virtual ~StackWithMin() {} T&amp;amp; top(); const T&amp;amp; top() const; void push(const T&amp;amp; value); void pop(); const T&amp;amp; min() const; bool empty() const; size_t size() const;private: stack&amp;lt;T&amp;gt; m_data; // 数据栈，存放栈的所有元素 stack&amp;lt;T&amp;gt; m_min; // 辅助栈，存放栈的最小元素};template &amp;lt;typename T&amp;gt; void StackWithMin&amp;lt;T&amp;gt;::push(const T&amp;amp; value){ m_data.push(value); if (m_min.size() == 0 || value &amp;lt; m_min.top()) m_min.push(value); else m_min.push(m_min.top());}template &amp;lt;typename T&amp;gt; void StackWithMin&amp;lt;T&amp;gt;::pop(){ m_min.pop(); m_data.pop();}template &amp;lt;typename T&amp;gt; const T&amp;amp; StackWithMin&amp;lt;T&amp;gt;::min() const{ assert(m_data.size() &amp;gt; 0); return m_min.top();}31 栈的压入、弹出序列 判断输出结构是否能有入栈顺序得出 如果下一个弹出的数字刚好是栈顶，则直接弹出，否则就压栈将待弹出树压到栈顶bool isPopOrder(const vector&amp;lt;int&amp;gt; pPush, const vector&amp;lt;int&amp;gt; pPop){ if (pPush.size() != pPop.size()) return false; stack&amp;lt;int&amp;gt; stc; for (int i = 0, j = 0;i &amp;lt; pPush.size();i++) { stc.push(pPush[i]); while (j&amp;lt;pPop.size()&amp;amp;&amp;amp;stc.top()==pPop[j]) { stc.pop(); j++; } } return stc.empty(); // 通过判断栈是否为空，来判断是否是输出}32 层序遍历二叉树，并按层输出 每层添加标志，每打印一次，toBePrinted减1 每压栈一次，nextlevelsize加1void Print(BinaryTree* pRoot){ queue&amp;lt;BinaryTree*&amp;gt; q; q.push(pRoot); int toBePrinted = 1; int nextLevelSize = 0; while (!q.empty()) { BinaryTree* print_one = q.front(); cout &amp;lt;&amp;lt; print_one-&amp;gt;b_value &amp;lt;&amp;lt; &#39; &#39;; if (print_one-&amp;gt;b_left) { q.push(print_one-&amp;gt;b_left); nextLevelSize++; } if (print_one-&amp;gt;b_right) { q.push(print_one-&amp;gt;b_right); nextLevelSize++; } q.pop(); toBePrinted--; if (toBePrinted == 0) { cout &amp;lt;&amp;lt; &#39;\\n&#39;; toBePrinted = nextLevelSize; nextLevelSize = 0; } }}33 判断是不是二叉搜索树的后序遍历 先找根节点 再分左右子节点 左子树都小于根节点，右子树都小于根节点 思路是先假定是后序遍历，检测它符合二叉搜索树的条件 bool sequenceofBST(int sequence[],int length){ if (sequence==nullptr) return false; int root = sequence[length - 1]; int i = 0; int j = 0; // 找左子树 for (i = 0;i &amp;lt; length - 1;i++) { if (sequence[i] &amp;gt; root) break; } // 右子树都大于root for (j = i;j &amp;lt; length - 1;j--) { if (sequence[j] &amp;lt; root) return false; } // 判断左子树是否为BTS bool left = false; left = sequenceofBST(sequence, i); // 判断右子树是否为BFS bool right = false; right = sequenceofBST(sequence + i, length - 1 - i); return (right&amp;amp;&amp;amp;left);}34 二叉树中和为某一值的路径 判断是否是叶子节点 判断所有的和是不是相等 打印路径时候需要访问每个元素，遂用vector实现栈的功能// currentSum 初始化为0void FindPath(BinaryTree* a, int Sum, vector&amp;lt;int&amp;gt; &amp;amp; path, int currentSum){ currentSum += a-&amp;gt;b_value; path.push_back(a-&amp;gt;b_value); // 判断是否是叶节点，是否和相同 bool ifLeaf = a-&amp;gt;b_left == nullptr&amp;amp;&amp;amp;a-&amp;gt;b_right == nullptr; if (currentSum == Sum &amp;amp;&amp;amp; ifLeaf) { cout &amp;lt;&amp;lt; &quot;A path is found \\n&quot;; vector&amp;lt;int&amp;gt;::iterator it = path.begin(); for (;it != path.end();it++) cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &#39; &#39;; } // 若不是叶节点，遍历子节点 if (a-&amp;gt;b_left != nullptr) FindPath(a, Sum, path, currentSum); if (a-&amp;gt;b_right != nullptr) FindPath(a, Sum, path, currentSum); // 每次都肯定会返回父节点，则要弹出最后一位 path.pop_back();}35 复杂链表的复制 方法一：先复制，再挨个从链表头部找pSibiling，时间负责都为O(n^2) 方法二: 空间复杂度换时间复杂度,利用哈希表,建立复制前后链表之间的联系 方法三: 将复制的放在被复制的后面,则不需要空间消耗:A,A’,B,B’// 复制链表，插空连接void CloneNodes(complexListNode* pHead){ complexListNode* pNode = pHead; while (pNode != nullptr) { complexListNode* pCloned = new complexListNode(); pCloned-&amp;gt;p_value = pNode-&amp;gt;p_value; pCloned-&amp;gt;p_next = pNode-&amp;gt;p_next; pCloned-&amp;gt;p_sibiling = nullptr; pNode-&amp;gt;p_next = pCloned; pNode = pCloned-&amp;gt;p_next; }}// 设置p_sibilingvoid connectSibilingNodes(complexListNode* pHead){ complexListNode* pNode = pHead; while (pNode != nullptr) { complexListNode* pCloned = pNode-&amp;gt;p_next; if (pNode-&amp;gt;p_sibiling != nullptr) pCloned-&amp;gt;p_sibiling = pNode-&amp;gt;p_sibiling-&amp;gt;p_next; pNode = pCloned-&amp;gt;p_next; }}// 把长链表分成两个链表，奇数偶数complexListNode* ReconectedNodes(complexListNode* pHead){ complexListNode* pNode = pHead; complexListNode* pClondeHead = nullptr; complexListNode* pClonedNode = nullptr; // 构建克隆链表的链表头 if (pNode!=nullptr) { pClondeHead = pClonedNode = pNode-&amp;gt;p_next; pNode-&amp;gt;p_next = pClonedNode-&amp;gt;p_next; pNode = pNode-&amp;gt;p_next; } // 循环分开两个链表 while (pNode!=nullptr) { pClonedNode-&amp;gt;p_next = pNode-&amp;gt;p_next; pClonedNode = pClonedNode-&amp;gt;p_next; pNode-&amp;gt;p_next = pClonedNode-&amp;gt;p_next; pNode = pNode-&amp;gt;p_next; } return pClonedNode;}38 字符串的排列 思路:固定第一个,找下面的排序可能 实现:使用递归void Permutation(char* pStr, char* pBegin){ if (*pBegin == &#39;\\0&#39;) cout &amp;lt;&amp;lt; pStr &amp;lt;&amp;lt; endl; else { for (char* pCh = pBegin;*pCh != &#39;\\0&#39;;pCh++) { // 列出所有可能的头部 // 通过将第一个与后面的顺次交换 char temp = *pCh; *pCh = *pBegin; *pBegin = temp; // 定好第一个数，在递归进行下一个数的确定 Permutation(pStr, pBegin + 1); // 恢复成初始的字符状态 temp = *pCh; *pCh = *pBegin; *pBegin = temp; } }}39 数组中出现次数超过一半的数字 基于快排,但基于的数在middle位置的时候,即为此数 40 最小的K个数 修改数组–类似于快排的思路 最小堆的思路 void insert_p(vector&amp;lt;int&amp;gt; &amp;amp;a, int p){ while (p &amp;gt; 0) { int parent = (p - 1) / 2; if(a[parent] &amp;gt; a[p]) // if (a[parent] &amp;lt; a[p]) { swap(a[parent], a[p]); p = parent; } else break; }}void delete_min(vector&amp;lt;int&amp;gt; &amp;amp;a, int length){ int tmp = a[0]; int index = 0; // 找出最大的 // large指向已遍历的最大值 // index指向当前空缺位置 while (1) { int left = 2 * index + 1; int right = 2 * index + 2; if (left &amp;gt;= length) break; else { int small = a[left] &amp;gt; a[right] ? right : left; a[index] = a[small]; index = small; } } a[index] = a[length]; a[length] = tmp;}void HeapSort(vector&amp;lt;int&amp;gt; &amp;amp;a){ for (int i = 0;i &amp;lt; a.size();i++) insert_p(a, i); for (int i = a.size() - 1;i &amp;gt; a.size() - 4;i--) delete_min(a, i);}int main(){ int myints[] = {7,15,9,2,16,45,6,7,32 }; vector&amp;lt;int&amp;gt; v(myints, myints + 9); HeapSort(v); for (int i = v.size()-1;i &amp;gt; v.size() - 4;i--) cout &amp;lt;&amp;lt; v[i] &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; endl; system(&quot;pause&quot;);}41 数据流的中位数 使用最大堆和最小堆的方式来实现 数据均分为两部分,a为最大堆的堆顶,b为最小堆的堆顶 确保a&amp;lt;b,即最小堆的所有数大于最大堆的所有数 插入min中的数,若比max[0]小,则先取max中的最大值 插入max中的数,若比min[0]大,则先取min中的最小值 二叉树数的相关知识class BinTree{public: int data; BinTree *leftChild; BinTree *rightChild; BinTree() { leftChild = NULL; rightChild = NULL; }};// 通过递归构建二叉树BinTree *CreateBinTree(){ int data; BinTree *T; cin &amp;gt;&amp;gt; data; if (data == -1) T = NULL; else { T = new BinTree();// 初始化 T-&amp;gt;data = data; T-&amp;gt;leftChild = CreateBinTree(); T-&amp;gt;rightChild = CreateBinTree(); } return T;}// 前序遍历void PreTravel(BinTree* tree){ if (tree) { cout &amp;lt;&amp;lt; tree-&amp;gt;data &amp;lt;&amp;lt; &quot; &quot;; PreTravel(tree-&amp;gt;leftChild); PreTravel(tree-&amp;gt;rightChild); }}// 中序遍历void InTravel(BinTree* tree){ if (tree) { InTravel(tree-&amp;gt;leftChild); cout &amp;lt;&amp;lt; tree-&amp;gt;data &amp;lt;&amp;lt; &quot; &quot;; InTravel(tree-&amp;gt;rightChild); }}// 后序遍历void PostTravel(BinTree* tree){ if (tree) { PostTravel(tree-&amp;gt;leftChild); PostTravel(tree-&amp;gt;rightChild); cout &amp;lt;&amp;lt; tree-&amp;gt;data &amp;lt;&amp;lt; &quot; &quot;; }}// 层序遍历void LevelTravel(BinTree* tree){ queue&amp;lt;BinTree*&amp;gt; q; q.push(tree); while (!q.empty()) { // cout &amp;lt;&amp;lt; q.size() &amp;lt;&amp;lt;&quot;&amp;amp; &quot;&amp;lt;&amp;lt;endl; BinTree *temp = q.front(); q.pop(); cout &amp;lt;&amp;lt; temp-&amp;gt;data &amp;lt;&amp;lt; &quot; &quot;; if (temp-&amp;gt;leftChild) q.push(temp-&amp;gt;leftChild); if (temp-&amp;gt;rightChild) q.push(temp-&amp;gt;rightChild); }}// 插入数--构建出的是搜索二叉树void InsertTree(BinTree* &amp;amp;tree, int data){ if (tree == NULL) { tree = new BinTree(); tree-&amp;gt;data = data; } else if(tree-&amp;gt;data&amp;gt;data) { InsertTree(tree-&amp;gt;leftChild, data); } else if (tree-&amp;gt;data &amp;lt; data) { InsertTree(tree-&amp;gt;rightChild, data); }}// 查找树的最小值，树是中序排列int finMin(BinTree *tree){ if (tree == NULL) return -1; else if (tree-&amp;gt;leftChild == NULL) return tree-&amp;gt;data; else return finMin(tree-&amp;gt;leftChild);}// 查找树的最大值int finMax(BinTree *tree){ if (tree == NULL) return -1; else if (tree-&amp;gt;rightChild == NULL) return tree-&amp;gt;data; else return finMax(tree-&amp;gt;rightChild);}// 删除函数void RemoveTree(BinTree* &amp;amp;tree, int data){ if (tree == NULL) return; if (data&amp;lt;tree-&amp;gt;data) RemoveTree(tree-&amp;gt;leftChild, data); else if (data&amp;gt;tree-&amp;gt;data) RemoveTree(tree-&amp;gt;rightChild, data); else if (tree-&amp;gt;leftChild &amp;amp;&amp;amp; tree-&amp;gt;rightChild) { tree-&amp;gt;data = finMin(tree-&amp;gt;rightChild); RemoveTree(tree-&amp;gt;rightChild, tree-&amp;gt;data);// 回归 } else { // 左空，右上，否则，左上 tree = (tree-&amp;gt;leftChild) ? tree-&amp;gt;leftChild : tree-&amp;gt;rightChild; }}int main(){ BinTree *tree = NULL; /*cout &amp;lt;&amp;lt; &quot;Please input a tree with PreOrder,use -1 as NULL&quot; &amp;lt;&amp;lt; endl; tree = CreateBinTree(); cout &amp;lt;&amp;lt; &quot;PreOrder Traversal&quot; &amp;lt;&amp;lt; endl; PreTravel(tree); cout &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &quot;InOrder Traversal&quot; &amp;lt;&amp;lt; endl; InTravel(tree); cout &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &quot;PostOrder Traversal&quot; &amp;lt;&amp;lt; endl; PostTravel(tree); cout &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &quot;LevelOrder Traversal&quot; &amp;lt;&amp;lt; endl; LevelTravel(tree); cout &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; endl;*/ int a; for (int i=0;i &amp;lt; 6;i++) { cout &amp;lt;&amp;lt; &quot;Input a node&quot; &amp;lt;&amp;lt; endl; cin &amp;gt;&amp;gt; a; InsertTree(tree, a); } cout &amp;lt;&amp;lt; &quot;LevelOrder Traversal&quot; &amp;lt;&amp;lt; endl; LevelTravel(tree); cout &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; endl; RemoveTree(tree, 2); cout &amp;lt;&amp;lt; &quot;LevelOrder Traversal&quot; &amp;lt;&amp;lt; endl; LevelTravel(tree); cout &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; endl; system(&quot;pause&quot;); return 0;}" }, { "title": "Design Patterns", "url": "/24/posts/design-patterns/", "categories": "C++, Basic", "tags": "c++", "date": "2019-08-12 11:33:00 +0800", "snippet": "工厂模式 创建对象时不暴露创建逻辑 使用共同接口指向新创建的对象 应用场景：创建复杂对象时 模式 产品数 工厂数 产品/工程 简单工程 多 1 多/1 工厂方法 多 多 1/1 抽象工厂 多 多 多/1 简单工程模式 特点：在工厂类中作判断，增加新产品时，修改工厂类 优点：只需要知道具体的产品型号就可以创建产品 缺点：若产品量大，工厂类会臃肿/*关键代码：创建过程在工厂类中完成*/​#include &amp;lt;iostream&amp;gt;​using namespace std;​//定义产品类型信息typedef enum{ Tank_Type_56, Tank_Type_96, Tank_Type_Num}Tank_Type;​//抽象产品类class Tank{public: virtual const string&amp;amp; type() = 0;};​//具体的产品类class Tank56 : public Tank{public: Tank56():Tank(),m_strType(&quot;Tank56&quot;) { }​ const string&amp;amp; type() override { cout &amp;lt;&amp;lt; m_strType.data() &amp;lt;&amp;lt; endl; return m_strType; }private: string m_strType;};​//具体的产品类class Tank96 : public Tank{public: Tank96():Tank(),m_strType(&quot;Tank96&quot;) { } const string&amp;amp; type() override { cout &amp;lt;&amp;lt; m_strType.data() &amp;lt;&amp;lt; endl; return m_strType; }​private: string m_strType;}; ​//工厂类class TankFactory{public: //根据产品信息创建具体的产品类实例，返回一个抽象产品类 Tank* createTank(Tank_Type type) { switch(type) { case Tank_Type_56: return new Tank56(); case Tank_Type_96: return new Tank96(); default: return nullptr; } }};​​int main(){ TankFactory* factory = new TankFactory(); Tank* tank56 = factory-&amp;gt;createTank(Tank_Type_56); tank56-&amp;gt;type(); Tank* tank96 = factory-&amp;gt;createTank(Tank_Type_96); tank96-&amp;gt;type();​ delete tank96; tank96 = nullptr; delete tank56; tank56 = nullptr; delete factory; factory = nullptr;​ return 0;}工厂方法模式 定义创建对象的接口，由子类完成创建 优点：增加新类，只需拓展相应的工厂类 缺点：产品太多时，需要大量工厂类/*关键代码：创建过程在其子类执行。*/​#include &amp;lt;iostream&amp;gt;​using namespace std;​//产品抽象类class Tank{public: virtual const string&amp;amp; type() = 0;};​//具体的产品类class Tank56 : public Tank{public: Tank56():Tank(),m_strType(&quot;Tank56&quot;) { }​ const string&amp;amp; type() override { cout &amp;lt;&amp;lt; m_strType.data() &amp;lt;&amp;lt; endl; return m_strType; }private: string m_strType;};​//具体的产品类class Tank96 : public Tank{public: Tank96():Tank(),m_strType(&quot;Tank96&quot;) { } const string&amp;amp; type() override { cout &amp;lt;&amp;lt; m_strType.data() &amp;lt;&amp;lt; endl; return m_strType; }​private: string m_strType;}; ​//抽象工厂类，提供一个创建接口class TankFactory{public: //提供创建产品实例的接口，返回抽象产品类 virtual Tank* createTank() = 0;};​//具体的创建工厂类，使用抽象工厂类提供的接口，去创建具体的产品实例class Tank56Factory : public TankFactory{public: Tank* createTank() override { return new Tank56(); }};​//具体的创建工厂类，使用抽象工厂类提供的接口，去创建具体的产品实例class Tank96Factory : public TankFactory{public: Tank* createTank() override { return new Tank96(); }};​​int main(){ TankFactory* factory56 = new Tank56Factory(); Tank* tank56 = factory56-&amp;gt;createTank(); tank56-&amp;gt;type(); TankFactory* factory96 = new Tank96Factory(); Tank* tank96 = factory96-&amp;gt;createTank(); tank96-&amp;gt;type();​ delete tank96; tank96 = nullptr; delete factory96; factory96 = nullptr;​ delete tank56; tank56 = nullptr; delete factory56; factory56 = nullptr;​ return 0;}抽象工厂模式 创建一系列接口，不指定具体的类 应用场景：存在多个产品系列，但客户端只是用一个系列产品 缺点：当增加一个新系列的产品时，不仅需要现实具体的产品类，还需要增加一个新的创建接口，扩展相对困难。/** 关键代码：在一个工厂里聚合多个同类产品。* 以下代码以白色衣服和黑色衣服为例，白色衣服为一个产品系列，黑色衣服为一个产品系列。白色上衣搭配白色裤子， 黑色上衣搭配黑色裤字。每个系列的衣服由一个对应的工厂创建，这样一个工厂创建的衣服能保证衣服为同一个系列。*/​//抽象上衣类class Coat{public: virtual const string&amp;amp; color() = 0;};​//黑色上衣类class BlackCoat : public Coat{public: BlackCoat():Coat(),m_strColor(&quot;Black Coat&quot;) { }​ const string&amp;amp; color() override { cout &amp;lt;&amp;lt; m_strColor.data() &amp;lt;&amp;lt; endl; return m_strColor; }private: string m_strColor;};​//白色上衣类class WhiteCoat : public Coat{public: WhiteCoat():Coat(),m_strColor(&quot;White Coat&quot;) { } const string&amp;amp; color() override { cout &amp;lt;&amp;lt; m_strColor.data() &amp;lt;&amp;lt; endl; return m_strColor; }​private: string m_strColor;}; ​//抽象裤子类class Pants{public: virtual const string&amp;amp; color() = 0;};​//黑色裤子类class BlackPants : public Pants{public: BlackPants():Pants(),m_strColor(&quot;Black Pants&quot;) { } const string&amp;amp; color() override { cout &amp;lt;&amp;lt; m_strColor.data() &amp;lt;&amp;lt; endl; return m_strColor; }​private: string m_strColor;};​//白色裤子类class WhitePants : public Pants{public: WhitePants():Pants(),m_strColor(&quot;White Pants&quot;) { } const string&amp;amp; color() override { cout &amp;lt;&amp;lt; m_strColor.data() &amp;lt;&amp;lt; endl; return m_strColor; }​private: string m_strColor;};​//抽象工厂类，提供衣服创建接口class Factory{public: //上衣创建接口，返回抽象上衣类 virtual Coat* createCoat() = 0; //裤子创建接口，返回抽象裤子类 virtual Pants* createPants() = 0;};​//创建白色衣服的工厂类，具体实现创建白色上衣和白色裤子的接口class WhiteFactory : public Factory{public: Coat* createCoat() override { return new WhiteCoat(); }​ Pants* createPants() override { return new WhitePants(); }};​//创建黑色衣服的工厂类，具体实现创建黑色上衣和白色裤子的接口class BlackFactory : public Factory{ Coat* createCoat() override { return new BlackCoat(); }​ Pants* createPants() override { return new BlackPants(); }};策略模式 封装一系列算法，使算法独立于客户端变化 优点：比if...else降低了复杂度，更容易维护 缺点：需要定义大量策略类传统的策略模式实现/** 关键代码：实现同一个接口。* 以下代码实例中，以游戏角色不同的攻击方式为不同的策略，游戏角色即为执行不同策略的环境角色。*/​#include &amp;lt;iostream&amp;gt;​using namespace std;​//抽象策略类，提供一个接口class Hurt{public: virtual void blood() = 0;};​//具体的策略实现类，具体实现接口， Adc持续普通攻击class AdcHurt : public Hurt{public: void blood() override { cout &amp;lt;&amp;lt; &quot;Adc hurt, Blood loss&quot; &amp;lt;&amp;lt; endl; }};​//具体的策略实现类，具体实现接口， Apc技能攻击class ApcHurt : public Hurt{public: void blood() override { cout &amp;lt;&amp;lt; &quot;Apc Hurt, Blood loss&quot; &amp;lt;&amp;lt; endl; }};​//环境角色类， 游戏角色战士，传入一个策略类指针参数。class Soldier{public: Soldier(Hurt* hurt):m_pHurt(hurt) { } //在不同的策略下，该游戏角色表现出不同的攻击 void attack() { m_pHurt-&amp;gt;blood(); }private: Hurt* m_pHurt;};​//定义策略标签typedef enum{ Hurt_Type_Adc, Hurt_Type_Apc, Hurt_Type_Num}HurtType;​//环境角色类， 游戏角色法师，传入一个策略标签参数。class Mage{public: Mage(HurtType type) { switch(type) { case Hurt_Type_Adc: m_pHurt = new AdcHurt(); break; case Hurt_Type_Apc: m_pHurt = new ApcHurt(); break; default: break; } } ~Mage() { delete m_pHurt; m_pHurt = nullptr; cout &amp;lt;&amp;lt; &quot;~Mage()&quot; &amp;lt;&amp;lt; endl; }​ void attack() { m_pHurt-&amp;gt;blood(); }private: Hurt* m_pHurt;};​//环境角色类， 游戏角色弓箭手，实现模板传递策略。template&amp;lt;typename T&amp;gt;class Archer{public: void attack() { m_hurt.blood(); }private: T m_hurt;};​int main(){ Archer&amp;lt;ApcHurt&amp;gt;* arc = new Archer&amp;lt;ApcHurt&amp;gt;; arc-&amp;gt;attack();​ delete arc; arc = nullptr; return 0;}使用函数指针实现#include &amp;lt;iostream&amp;gt;#include &amp;lt;functional&amp;gt; ​void adcHurt(){ std::cout &amp;lt;&amp;lt; &quot;Adc Hurt&quot; &amp;lt;&amp;lt; std::endl;}​void apcHurt(){ std::cout &amp;lt;&amp;lt; &quot;Apc Hurt&quot; &amp;lt;&amp;lt; std::endl;}​//环境角色类， 使用传统的函数指针class Soldier{public: typedef void (*Function)(); Soldier(Function fun): m_fun(fun) { } void attack() { m_fun(); }private: Function m_fun;};​//环境角色类， 使用std::function&amp;lt;&amp;gt;class Mage{public: typedef std::function&amp;lt;void()&amp;gt; Function;​ Mage(Function fun): m_fun(fun) { } void attack() { m_fun(); }private: Function m_fun;};​int main(){ Soldier* soldier = new Soldier(apcHurt); soldier-&amp;gt;attack(); delete soldier; soldier = nullptr; return 0;}适配器模式 将一个类的接口转化成希望的另一个接口，实现多个类协作 缺点：过多使用适配器，让系统凌乱，不是很必要，可以不用适配器使用符合实现适配器模式/** 关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。* 以下示例中，假设我们之前有了一个双端队列，新的需求要求使用栈和队列来完成。 双端队列可以在头尾删减或增加元素。而栈是一种先进后出的数据结构，添加数据时添加到栈的顶部，删除数据时先删 除栈顶部的数据。因此我们完全可以将一个现有的双端队列适配成一个栈。*/​//双端队列， 被适配类class Deque{public: void push_back(int x) { cout &amp;lt;&amp;lt; &quot;Deque push_back:&quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; endl; } void push_front(int x) { cout &amp;lt;&amp;lt; &quot;Deque push_front:&quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; endl; } void pop_back() { cout &amp;lt;&amp;lt; &quot;Deque pop_back&quot; &amp;lt;&amp;lt; endl; } void pop_front() { cout &amp;lt;&amp;lt; &quot;Deque pop_front&quot; &amp;lt;&amp;lt; endl; }};​//顺序类，抽象目标类class Sequence {public: virtual void push(int x) = 0; virtual void pop() = 0;};​//栈,后进先出, 适配类class Stack:public Sequence {public: //将元素添加到堆栈的顶部。 void push(int x) override { m_deque.push_front(x); } //从堆栈中删除顶部元素 void pop() override { m_deque.pop_front(); }private: Deque m_deque;};​//队列，先进先出，适配类class Queue:public Sequence {public: //将元素添加到队列尾部 void push(int x) override { m_deque.push_back(x); } //从队列中删除顶部元素 void pop() override { m_deque.pop_front(); }private: Deque m_deque;};使用继承实现适配器模式//双端队列，被适配类class Deque {public: void push_back(int x) { cout &amp;lt;&amp;lt; &quot;Deque push_back:&quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; endl; } void push_front(int x) { cout &amp;lt;&amp;lt; &quot;Deque push_front:&quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; endl; } void pop_back() { cout &amp;lt;&amp;lt; &quot;Deque pop_back&quot; &amp;lt;&amp;lt; endl; } void pop_front() { cout &amp;lt;&amp;lt; &quot;Deque pop_front&quot; &amp;lt;&amp;lt; endl; }};​//顺序类，抽象目标类class Sequence {public: virtual void push(int x) = 0; virtual void pop() = 0;};​//栈,后进先出, 适配类class Stack:public Sequence, private Deque {public: void push(int x) { push_front(x); } void pop() { pop_front(); }};​//队列，先进先出，适配类class Queue:public Sequence, private Deque {public: void push(int x) { push_back(x); } void pop() { pop_front(); }};单例模式 保证一个类仅可以有一个实例化对象，并提供一个访问的全局接口 单例类只能由一个实例化对象。 单例类必须自己提供一个实例化对象。 单例类必须提供一个可以访问唯一实例化对象的接口。 懒汉单例模式 不到万不得已就不去实例化类，即第一次用类才去实例化 针对访问量小，甚至不去访问的情况，采用懒汉非线程安全的懒汉单例/** 关键代码：构造函数是私有的，不能通过赋值运算，拷贝构造等方式实例化对象。*/​//懒汉式一般实现：非线程安全，getInstance返回的实例指针需要deleteclass Singleton{public: static Singleton* getInstance(); ~Singleton(){}​private: Singleton(){} //构造函数私有 Singleton(const Singleton&amp;amp; obj) = delete; //明确拒绝 Singleton&amp;amp; operator=(const Singleton&amp;amp; obj) = delete; //明确拒绝 static Singleton* m_pSingleton;};​Singleton* Singleton::m_pSingleton = NULL;​Singleton* Singleton::getInstance(){ if(m_pSingleton == NULL) { m_pSingleton = new Singleton; } return m_pSingleton;}线程安全的懒汉单例std::mutex mt;class Singleton{public: static Singleton* getInstance();private: Singleton(){} //构造函数私有 Singleton(const Singleton&amp;amp;) = delete; //明确拒绝 Singleton&amp;amp; operator=(const Singleton&amp;amp;) = delete; //明确拒绝 static Singleton* m_pSingleton; };Singleton* Singleton::m_pSingleton = NULL;Singleton* Singleton::getInstance(){ if(m_pSingleton == NULL) { mt.lock(); if(m_pSingleton == NULL) { m_pSingleton = new Singleton(); } mt.unlock(); } return m_pSingleton;}返回一个reference指向local static对象class Singleton{public: static Singleton&amp;amp; getInstance();private: Singleton(){} Singleton(const Singleton&amp;amp;) = delete; //明确拒绝 Singleton&amp;amp; operator=(const Singleton&amp;amp;) = delete; //明确拒绝};​​Singleton&amp;amp; Singleton::getInstance(){ static Singleton singleton; return singleton;}饿汉单例模式 在单例类定义的时候就进行实例化//饿汉式：线程安全，注意一定要在合适的地方去delete它class Singleton{public: static Singleton* getInstance();private: Singleton(){} //构造函数私有 Singleton(const Singleton&amp;amp;) = delete; //明确拒绝 Singleton&amp;amp; operator=(const Singleton&amp;amp;) = delete; //明确拒绝​ static Singleton* m_pSingleton;};​Singleton* Singleton::m_pSingleton = new Singleton();​Singleton* Singleton::getInstance(){ return m_pSingleton;}" }, { "title": "Customize the Favicon", "url": "/24/posts/customize-the-favicon/", "categories": "Blogging, Tutorial", "tags": "favicon", "date": "2019-08-11 00:34:00 +0800", "snippet": "The favicons of Chirpy are placed in the directory assets/img/favicons/. You may want to replace them with your own. The following sections will guide you to create and replace the default favicons.Generate the faviconPrepare a square image (PNG, JPG, or SVG) with a size of 512x512 or more, and then go to the online tool Real Favicon Generator and click the button Select your Favicon image to upload your image file.In the next step, the webpage will show all usage scenarios. You can keep the default options, scroll to the bottom of the page, and click the button Generate your Favicons and HTML code to generate the favicon.Download &amp;amp; ReplaceDownload the generated package, unzip and delete the following two from the extracted files: browserconfig.xml site.webmanifestAnd then copy the remaining image files (PNG and ICO) to cover the original files in the directory assets/img/favicons/ of your Jekyll site. If your Jekyll site doesn’t have this directory yet, just create one.The following table will help you understand the changes to the favicon files: File(s) From Online Tool From Chirpy *.PNG ✓ ✗ *.ICO ✓ ✗ Note: ✓ means keep, ✗ means delete.The next time you build the site, the favicon will be replaced with a customized edition." }, { "title": "Getting Started", "url": "/24/posts/getting-started/", "categories": "Blogging, Tutorial", "tags": "getting started", "date": "2019-08-09 20:55:00 +0800", "snippet": "PrerequisitesFollow the instructions in the Jekyll Docs to complete the installation of Ruby, RubyGems, Jekyll, and Bundler.InstallationCreating a New SiteThere are two ways to create a new repository for this theme: Using the Chirpy Starter - Easy to upgrade, isolates irrelevant project files so you can focus on writing. Forking on GitHub - Convenient for custom development, but difficult to upgrade. Unless you are familiar with Jekyll and are determined to tweak or contribute to this project, this approach is not recommended.Option 1. Using the Chirpy StarterCreate a new repository from the Chirpy Starter and name it &amp;lt;GH_USERNAME&amp;gt;.github.io, where GH_USERNAME represents your GitHub username.Option 2. Forking on GitHubFork Chirpy on GitHub and rename it to &amp;lt;GH_USERNAME&amp;gt;.github.io. Please note that the default branch code is in development. If you want the site to be stable, please switch to the latest tag and start writing.And then execute:$ bash tools/init.sh Note: If you don’t want to deploy your site on GitHub Pages, append option --no-gh at the end of the above command.The above command will: Removes some files or directories from your repository: .travis.yml files under _posts folder docs If the option --no-gh is provided, the directory .github will be deleted. Otherwise, set up the GitHub Action workflow by removing the extension .hook of .github/workflows/pages-deploy.yml.hook, and then remove the other files and directories in the folder .github. Removes item Gemfile.lock from .gitignore. Creates a new commit to save the changes automatically.Installing DependenciesBefore running for the first time, go to the root directory of your site, and install dependencies as follows:$ bundleUsageConfigurationUpdate the variables of _config.yml as needed. Some of them are typical options: url avatar timezone langCustoming StylesheetIf you need to customize the stylesheet, copy the theme’s assets/css/style.scss to the same path on your Jekyll site, and then add the custom style at the end of the style file.Starting from v4.1.0, if you want to overwrite the SASS variables defined in _sass/addon/variables.scss, create a new file _sass/variables-hook.scss and assign new values to the target variable in it.Running Local ServerYou may want to preview the site contents before publishing, so just run it by:$ bundle exec jekyll sOr run the site on Docker with the following command:$ docker run -it --rm \\ --volume=&quot;$PWD:/srv/jekyll&quot; \\ -p 4000:4000 jekyll/jekyll \\ jekyll serveAfter a while, the local service will be published at http://127.0.0.1:4000.DeploymentBefore the deployment begins, check out the file _config.yml and make sure the url is configured correctly. Furthermore, if you prefer the project site and don’t use a custom domain, or you want to visit your website with a base URL on a web server other than GitHub Pages, remember to change the baseurl to your project name that starts with a slash, e.g, /project-name.Now you can choose ONE of the following methods to deploy your Jekyll site.Deploy by Using Github ActionsFor security reasons, GitHub Pages build runs on safe mode, which restricts us from using plugins to generate additional page files. Therefore, we can use GitHub Actions to build the site, store the built site files on a new branch, and use that branch as the source of the GitHub Pages service.Quickly check the files needed for GitHub Actions build: Ensure your Jekyll site has the file .github/workflows/pages-deploy.yml. Otherwise, create a new one and fill in the contents of the sample file, and the value of the on.push.branches should be the same as your repo’s default branch name. Ensure your Jekyll site has file tools/deploy.sh. Otherwise, copy it from here to your Jekyll site. Furthermore, if you have committed Gemfile.lock to the repo, and your runtime system is not Linux, don’t forget to update the platform list in the lock file: $ bundle lock --add-platform x86_64-linux After the above steps, rename your repository to &amp;lt;GH_USERNAME&amp;gt;.github.io on GitHub.Now publish your Jekyll site by: Push any commit to remote to trigger the GitHub Actions workflow. Once the build is complete and successful, a new remote branch named gh-pages will appear to store the built site files. Browse to your repository on GitHub. Select the tab Settings, then click Pages in the left navigation bar, and then in the section Source of GitHub Pages, select the /(root) directory of branch gh-pages as the publishing source. Remember to click Save before leaving. Visit your website at the address indicated by GitHub. Manually Build and DeployOn self-hosted servers, you cannot enjoy the convenience of GitHub Actions. Therefore, you should build the site on your local machine and then upload the site files to the server.Go to the root of the source project, and build your site as follows:$ JEKYLL_ENV=production bundle exec jekyll bOr build the site on Docker:$ docker run -it --rm \\ --env JEKYLL_ENV=production \\ --volume=&quot;$PWD:/srv/jekyll&quot; \\ jekyll/jekyll \\ jekyll buildUnless you specified the output path, the generated site files will be placed in folder _site of the project’s root directory. Now you should upload those files to the target server.UpgradingIt depends on how you use the theme: If you are using the theme gem (there will be gem &quot;jekyll-theme-chirpy&quot; in the Gemfile), editing the Gemfile and update the version number of the theme gem, for example: - gem &quot;jekyll-theme-chirpy&quot;, &quot;~&amp;gt; 3.2&quot;, &quot;&amp;gt;= 3.2.1&quot;+ gem &quot;jekyll-theme-chirpy&quot;, &quot;~&amp;gt; 3.3&quot;, &quot;&amp;gt;= 3.3.0&quot; And then execute the following command: $ bundle update jekyll-theme-chirpy As the version upgrades, the critical files (for details, see the Startup Template) and configuration options will change. Please refer to the Upgrade Guide to keep your repo’s files in sync with the latest version of the theme. If you forked from the source project (there will be gemspec in the Gemfile of your site), then merge the latest upstream tags into your Jekyll site to complete the upgrade.The merge is likely to conflict with your local modifications. Please be patient and careful to resolve these conflicts. " }, { "title": "Writing a New Post", "url": "/24/posts/write-a-new-post/", "categories": "Blogging, Tutorial", "tags": "writing", "date": "2019-08-08 14:10:00 +0800", "snippet": "This post will guide you how to write a post on Chirpy theme. Even if you have previous experience with Jekyll, this article is worth reading, because many features require specific variables to be set.Naming and PathCreate a new file named YYYY-MM-DD-TITLE.EXTENSION and put it in the _posts of the root directory. Please note that the EXTENSION must be one of md and markdown. If you want to save time of creating files, please consider using the plugin Jekyll-Compose to accomplish this.Front MatterBasically, you need to fill the Front Matter as below at the top of the post:---title: TITLEdate: YYYY-MM-DD HH:MM:SS +/-TTTTcategories: [TOP_CATEGORIE, SUB_CATEGORIE]tags: [TAG] # TAG names should always be lowercase--- Note: The posts’ layout has been set to post by default, so there is no need to add the variable layout in the Front Matter block.Timezone of DateIn order to accurately record the release date of a post, you should not only set up the timezone of _config.yml but also provide the post’s timezone in variable date of its Front Matter block. Format: +/-TTTT, e.g. +0800.Categories and TagsThe categories of each post are designed to contain up to two elements, and the number of elements in tags can be zero to infinity. For instance:---categories: [Animal, Insect]tags: [bee]---Author InformationThe author information of the post usually does not need to be filled in the Front Matter , they will be obtained from variables social.name and the first entry of social.links of the configuration file by default. But you can also override it as follows:---author: name: Full Name link: https://example.com---Table of ContentsBy default, the Table of Contents (TOC) is displayed on the right panel of the post. If you want to turn it off globally, go to _config.yml and set the value of variable toc to false. If you want to turn off TOC for a specific post, add the following to the post’s Front Matter:---toc: false---CommentsThe global switch of comments is defined by variable comments.active in the file _config.yml. After selecting a comment system for this variable, comments will be turned on for all posts.If you want to close the comment for a specific post, add the following to the Front Matter of the post:---comments: false---MathematicsFor website performance reasons, the mathematical feature won’t be loaded by default. But it can be enabled by:---math: true---MermaidMermaid is a great diagrams generation tool. To enable it on your post, add the following to the YAML block:---mermaid: true---Then you can use it like other markdown languages: surround the graph code with ```mermaid and ```.ImagesCaptionAdd italics to the next line of an image，then it will become the caption and appear at the bottom of the image:![img-description](/path/to/image)_Image Caption_SizeIn order to prevent the page content layout from shifting when the image is loaded, we should set the width and height for each image:![Desktop View](/assets/img/sample/mockup.png){: width=&quot;700&quot; height=&quot;400&quot; }Starting from Chirpy v5.0.0, height and width support abbreviations (height → h, width → w). The following example has the same effect as the above:![Desktop View](/assets/img/sample/mockup.png){: w=&quot;700&quot; h=&quot;400&quot; }PositionBy default, the image is centered, but you can specify the position by using one of the classes normal, left, and right. For example: Normal position Image will be left aligned in below sample: ![Desktop View](/assets/img/sample/mockup.png){: .normal } Float to the left ![Desktop View](/assets/img/sample/mockup.png){: .left } Float to the right ![Desktop View](/assets/img/sample/mockup.png){: .right } Limitation: Once the position of the image is specified, the image caption should not be added.ShadowThe screenshots of the program window can be considered to show the shadow effect, and the shadow will be visible in the light mode:![Desktop View](/assets/img/sample/mockup.png){: .shadow }CDN URLIf you host the images on the CDN, you can save the time of repeatedly writing the CDN URL by assigning the variable img_cdn of _config.yml file:img_cdn: https://cdn.comOnce img_cdn is assigned, the CDN URL will be added to the path of all images (images of site avatar and posts) starting with /.For instance, when using images:![The flower](/path/to/flower.png)The parsing result will automatically add the CDN prefix https://cdn.com before the image path:&amp;lt;img src=&quot;https://cdn.com/path/to/flower.png&quot; alt=&quot;The flower&quot;&amp;gt;Image PathWhen a post contains many images, it will be a time-consuming task to repeatedly define the path of the images. To solve this, we can define this path in the YAML block of the post:---img_path: /img/path/---And then, the image source of Markdown can write the file name directly:![The flower](flower.png)The output will be:&amp;lt;img src=&quot;/img/path/flower.png&quot; alt=&quot;The flower&quot;&amp;gt;Preview ImageIf you want to add an image to the top of the post contents, specify the attribute src, width, height, and alt for the image:---image: src: /path/to/image/file width: 1000 # in pixels height: 400 # in pixels alt: image alternative text---Except for alt, all other options are necessary, especially the width and height, which are related to user experience and web page loading performance. The above section “Size” also mentions this.Starting from Chirpy v5.0.0, the attributes height and width can be abbreviated: height → h, width → w. In addition, the img_path can also be passed to the preview image, that is, when it has been set, the attribute src only needs the image file name.Pinned PostsYou can pin one or more posts to the top of the home page, and the fixed posts are sorted in reverse order according to their release date. Enable by:---pin: true---Code BlockMarkdown symbols ``` can easily create a code block as follows:This is a plaintext code snippet.Specifying LanguageUsing ```{language} you will get a code block with syntax highlight:```yamlkey: value``` Limitation: The Jekyll style highlight tag is not compatible with this theme.Line NumberBy default, all languages except plaintext, console, and terminal will display line numbers. When you want to hide the line number of the code block, you can append {: .nolineno} at the next line:```shellecho &#39;No more line numbers!&#39;```{: .nolineno}Specifying the FilenameYou may have noticed that the code language will be displayed on the left side of the header of the code block. If you want to replace it with the file name, you can add the attribute file to achieve this:```shell# content```{: file=&quot;path/to/file&quot; }Liquid CodesIf you want to display the Liquid snippet, surround the liquid code with {% raw %} and {% endraw %}:{% raw %}```liquid{% if product.title contains &#39;Pack&#39; %} This product&#39;s title contains the word Pack.{% endif %}```{% endraw %}Or adding render_with_liquid: false (Requires Jekyll 4.0 or higher) to the post’s YAML block.Learn MoreFor more knowledge about Jekyll posts, visit the Jekyll Docs: Posts." }, { "title": "Text and Typography", "url": "/24/posts/text-and-typography/", "categories": "Blogging, Demo", "tags": "typography", "date": "2019-08-08 11:33:00 +0800", "snippet": "This post is to show Markdown syntax rendering on Chirpy, you can also use it as an example of writing. Now, let’s start looking at text and typography.TitlesH1 - headingH2 - headingH3 - headingH4 - headingParagraphI wandered lonely as a cloudThat floats on high o’er vales and hills,When all at once I saw a crowd,A host, of golden daffodils;Beside the lake, beneath the trees,Fluttering and dancing in the breeze.ListsOrdered list Firstly Secondly ThirdlyUnordered list Chapter Section Paragraph Task list TODO Completed Defeat COVID-19 Vaccine production Economic recovery People smile again Description list Sun the star around which the earth orbits Moon the natural satellite of the earth, visible by reflected light from the sunBlock Quote This line to shows the Block Quote.Tables Company Contact Country Alfreds Futterkiste Maria Anders Germany Island Trading Helen Bennett UK Magazzini Alimentari Riuniti Giovanni Rovelli Italy Linkshttp://127.0.0.1:4000FootnoteClick the hook will locate the footnote1, and here is another footnote2.Images Default (with caption)Full screen width and center alignment Shadowshadow effect (visible in light mode) Left aligned Float to left “A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space.” Float to right “A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space.” Mermaid SVG gantt title Adding GANTT diagram functionality to mermaid apple :a, 2017-07-20, 1w banana :crit, b, 2017-07-23, 1d cherry :active, c, after b a, 1dMathematicsThe mathematics powered by MathJax:\\[\\sum_{n=1}^\\infty 1/n^2 = \\frac{\\pi^2}{6}\\]When $a \\ne 0$, there are two solutions to $ax^2 + bx + c = 0$ and they are\\[x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}\\]Inline codeThis is an example of Inline Code.Code blockCommonThis is a common code snippet, without syntax highlight and line number.Specific LanguagesConsole$ env |grep SHELLSHELL=/usr/local/bin/bashPYENV_SHELL=bashShellif [ $? -ne 0 ]; then echo &quot;The command was not successful.&quot;; #do the needful / exitfi;Specific filename@import &quot;colors/light-typography&quot;, &quot;colors/dark-typography&quot;Reverse Footnote The footnote source &amp;#8617; The 2nd footnote source &amp;#8617; " } ]
