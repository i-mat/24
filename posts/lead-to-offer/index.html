<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="Lead To Offer" /><meta name="author" content="Sean Mat" /><meta property="og:locale" content="en" /><meta name="description" content="3 数组-找出数组中重复的数字" /><meta property="og:description" content="3 数组-找出数组中重复的数字" /><link rel="canonical" href="https://i-mat.github.io/24/posts/lead-to-offer/" /><meta property="og:url" content="https://i-mat.github.io/24/posts/lead-to-offer/" /><meta property="og:site_name" content="Mat" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-08-19T11:33:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Lead To Offer" /><meta name="twitter:site" content="@digostar24" /><meta name="twitter:creator" content="@Sean Mat" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"Sean Mat"},"headline":"Lead To Offer","dateModified":"2019-08-19T11:33:00+08:00","datePublished":"2019-08-19T11:33:00+08:00","url":"https://i-mat.github.io/24/posts/lead-to-offer/","description":"3 数组-找出数组中重复的数字","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://i-mat.github.io/24/posts/lead-to-offer/"},"@context":"https://schema.org"}</script><title>Lead To Offer | Mat</title><link rel="apple-touch-icon" sizes="180x180" href="/24/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/24/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/24/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/24/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/24/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Mat"><meta name="application-name" content="Mat"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/24/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/24/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/24/" alt="avatar" class="mx-auto"> <img src="/24/assets/img/favicons/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/24/">Mat</a></div><div class="site-subtitle font-italic">O ever youthful, O ever weeping</div></div><ul class="w-100"><li class="nav-item"> <a href="/24/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/24/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/24/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/24/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/24/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/i-mat" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/digostar24" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['imatao','foxmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/24/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/24/"> Home </a> </span> <span>Lead To Offer</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 850 585'%3E%3C/svg%3E" data-src="/24/assets/img/posts/lead_offer.jpg" class="preview-img bg" alt="Preview Image" width="850" height="585" data-proofer-ignore><h1 data-toc-skip>Lead To Offer</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/i-mat">Sean Mat</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" date="2019-08-19 11:33:00 +0800" data-toggle="tooltip" data-placement="bottom" title="Mon, Aug 19, 2019, 11:33 AM +0800" >Aug 19, 2019</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7210 words"> <em>40 min</em> read</span></div></div></div><div class="post-content"><h2 id="3-数组-找出数组中重复的数字">3 数组-找出数组中重复的数字<a href="#3-数组-找出数组中重复的数字" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="nf">duplicate</span><span class="p">(</span><span class="kt">int</span> <span class="n">numbers</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">duplication</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 判断数组不为空</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">numbers</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// 判断数值在制定范围内</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// 从位置0开始交换</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">numbers</span><span class="p">[</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="p">{</span>
                <span class="o">*</span><span class="n">duplication</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">numbers</span><span class="p">[</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="31-数组-不修改数组找重复数字">3.1 数组-不修改数组找重复数字<a href="#31-数组-不修改数组找重复数字" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>利用二分法进行数组分割</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">countRange</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">numbers</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">);</span>

<span class="c1">// 参数:</span>
<span class="c1">//        numbers:     一个整数数组</span>
<span class="c1">//        length:      数组的长度</span>
<span class="c1">// 返回值:             </span>
<span class="c1">//        正数  - 输入有效，并且数组中存在重复的数字，返回值为重复的数字</span>
<span class="c1">//        负数  - 输入无效，或者数组中没有重复的数字</span>
<span class="kt">int</span> <span class="nf">getDuplication</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">numbers</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">numbers</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">end</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">middle</span> <span class="o">=</span> <span class="p">((</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">start</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">countRange</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">middle</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">end</span> <span class="o">==</span> <span class="n">start</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">start</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">middle</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">middle</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">countRange</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">numbers</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">numbers</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span>
            <span class="o">++</span><span class="n">count</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><h3 id="32-找出没有重复的数字">3.2 找出没有重复的数字<a href="#32-找出没有重复的数字" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>利用位运算–异或</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">^</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="4-数组-二维数组中的查找">4 数组-二维数组中的查找<a href="#4-数组-二维数组中的查找" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>数组由左到右 和 由上到下 均为递增；查找某个数<li>以数组的右上角或者左下角为突破口</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="nf">fintTarget</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">matrix</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span><span class="kt">int</span> <span class="n">column</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 判断在数的范围内</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="o">&lt;</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span> <span class="n">target</span><span class="o">&gt;</span><span class="n">matrix</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">column</span><span class="p">])</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">row_a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">column_a</span> <span class="o">=</span> <span class="n">column</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    
    <span class="c1">// 比右上角的数大，则到下一行，否则换到前一列</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">row_a</span> <span class="o">&lt;</span> <span class="n">row</span> <span class="o">&amp;&amp;</span> <span class="n">column</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">row_a</span><span class="p">][</span><span class="n">column_a</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">row_a</span><span class="p">][</span><span class="n">column_a</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="n">column_a</span><span class="o">--</span><span class="p">;</span>
        <span class="k">else</span> <span class="n">row_a</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="5-字符串-替换空格">5 字符串-替换空格<a href="#5-字符串-替换空格" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>双指针，一个指向末尾，一个指向拓展后的末尾</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
</pre><td class="rouge-code"><pre><span class="c1">// 基本方法</span>
<span class="kt">void</span> <span class="nf">replaceSpace</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span><span class="kt">int</span> <span class="n">length</span><span class="p">)</span> 
    <span class="p">{</span>
        <span class="c1">// 判断数据不为空</span>
        <span class="k">if</span><span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="nb">NULL</span><span class="o">||</span><span class="n">length</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">)</span>  <span class="k">return</span><span class="p">;</span>
        <span class="c1">// 拓展数据长度</span>
        <span class="kt">int</span> <span class="n">true_length</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">count_blank</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="sc">'\0'</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">true_length</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="sc">' '</span><span class="p">)</span>
                <span class="n">count_blank</span><span class="o">++</span><span class="p">;</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 计算拓展后的字符串长度，判断是否在length范围内</span>
        <span class="kt">int</span> <span class="n">new_length</span><span class="o">=</span><span class="n">true_length</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">count_blank</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">new_length</span><span class="o">&gt;</span><span class="n">length</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        
        <span class="c1">// 后移，替换</span>
        <span class="kt">int</span> <span class="n">a_pointer</span><span class="o">=</span><span class="n">true_length</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">b_pointer</span><span class="o">=</span><span class="n">new_length</span><span class="p">;</span>
        
        <span class="k">while</span><span class="p">(</span><span class="n">a_pointer</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">a_pointer</span><span class="o">&lt;</span><span class="n">b_pointer</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">a_pointer</span><span class="p">]</span><span class="o">!=</span><span class="sc">' '</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">str</span><span class="p">[</span><span class="n">b_pointer</span><span class="p">]</span><span class="o">=</span><span class="n">str</span><span class="p">[</span><span class="n">a_pointer</span><span class="p">];</span>
                <span class="n">a_pointer</span><span class="o">--</span><span class="p">;</span>
                <span class="n">b_pointer</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">a_pointer</span><span class="o">--</span><span class="p">;</span>
                <span class="n">str</span><span class="p">[</span><span class="n">b_pointer</span><span class="o">--</span><span class="p">]</span><span class="o">=</span><span class="sc">'0'</span><span class="p">;</span>
                <span class="n">str</span><span class="p">[</span><span class="n">b_pointer</span><span class="o">--</span><span class="p">]</span><span class="o">=</span><span class="sc">'2'</span><span class="p">;</span>
                <span class="n">str</span><span class="p">[</span><span class="n">b_pointer</span><span class="o">--</span><span class="p">]</span><span class="o">=</span><span class="sc">'%'</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>

<span class="c1">// STL的方法</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">a</span> <span class="o">=</span> <span class="s">"a time for you"</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">b</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">' '</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">b</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="sc">'%'</span><span class="p">);</span>
            <span class="n">b</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="sc">'2'</span><span class="p">);</span>
            <span class="n">b</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="sc">'0'</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
            <span class="n">b</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">string</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">b</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="6-链表-在链表结尾添加一个节点">6 链表-在链表结尾添加一个节点<a href="#6-链表-在链表结尾添加一个节点" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="c1">// 单向链表节点定义</span>
<span class="k">struct</span> <span class="nc">ListNode</span>
<span class="p">{</span>
    <span class="kt">int</span>       <span class="n">L_value</span><span class="p">;</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">L_next</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 添加节点</span>
<span class="kt">void</span> <span class="nf">AddToTail</span><span class="p">(</span><span class="n">ListNode</span><span class="o">**</span><span class="n">pHead</span><span class="p">,</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">pNew</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">();</span>
    <span class="n">pNew</span><span class="o">-&gt;</span><span class="n">L_value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">pNew</span><span class="o">-&gt;</span><span class="n">L_next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    
    <span class="c1">// 判断首节点是不是空节点</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pHead</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">*</span><span class="n">pHead</span> <span class="o">=</span> <span class="n">pNew</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">pNode</span> <span class="o">=</span> <span class="o">*</span><span class="n">pHead</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">pNode</span><span class="o">-&gt;</span><span class="n">L_next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="n">pNode</span> <span class="o">=</span> <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">L_next</span><span class="p">;</span>
        <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">L_next</span> <span class="o">=</span> <span class="n">pNew</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

</pre></table></code></div></div><h3 id="61-链表-删除某个节点">6.1 链表-删除某个节点<a href="#61-链表-删除某个节点" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">Remove</span><span class="p">(</span><span class="n">ListNode</span><span class="o">**</span><span class="n">pHead</span><span class="p">,</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">pNew</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">();</span>
    <span class="n">pNew</span><span class="o">-&gt;</span><span class="n">L_value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">pNew</span><span class="o">-&gt;</span><span class="n">L_next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pHead</span> <span class="o">==</span> <span class="nb">NULL</span><span class="o">||</span><span class="n">pHead</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 用来存放待删除的节点</span>
    <span class="n">ListNode</span><span class="o">*</span><span class="n">toBedeleted</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">pHead</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">L_value</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">toBedeleted</span> <span class="o">=</span> <span class="o">*</span><span class="n">pHead</span><span class="p">;</span>
        <span class="o">*</span><span class="n">pHead</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">pHead</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">L_next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">pNode</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">pHead</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">L_next</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">pNode</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">L_value</span> <span class="o">!=</span> <span class="n">value</span><span class="p">)</span>
            <span class="n">pNode</span> <span class="o">=</span> <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">L_next</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pNode</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">toBedeleted</span> <span class="o">=</span> <span class="n">pNode</span><span class="p">;</span>
            <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">L_next</span> <span class="o">=</span> <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">L_next</span><span class="o">-&gt;</span><span class="n">L_next</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">toBedeleted</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">delete</span> <span class="n">toBedeleted</span><span class="p">;</span>
        <span class="n">toBedeleted</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="62-链表-从尾到头打印链表">6.2 链表-从尾到头打印链表<a href="#62-链表-从尾到头打印链表" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>先进后出的情况，用栈来实现</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="c1">// 循环访问的方法</span>
<span class="kt">void</span> <span class="nf">PrintValueReverse</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span><span class="n">pHead</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 声明nodes的栈</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">nodes</span><span class="p">;</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">pNode</span> <span class="o">=</span> <span class="n">pHead</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">pNode</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">nodes</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">pNode</span><span class="o">-&gt;</span><span class="n">L_value</span><span class="p">);</span>
        <span class="n">pNode</span> <span class="o">=</span> <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">L_next</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// 输出nodes</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">nodes</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">nodes</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">nodes</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 递归的方法</span>
<span class="kt">void</span> <span class="nf">PrintValueReverse</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span><span class="n">pHead</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pHead</span><span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pHead</span><span class="o">-&gt;</span><span class="n">L_next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">PrintValueReverse</span><span class="p">(</span><span class="n">pHead</span><span class="o">-&gt;</span><span class="n">L_next</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pHead</span><span class="o">-&gt;</span><span class="n">L_value</span><span class="p">;</span>
    <span class="p">}</span>
    
<span class="p">}</span>
</pre></table></code></div></div><h2 id="7-树-重建二叉树">7 树-重建二叉树<a href="#7-树-重建二叉树" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><a href="https://www.cnblogs.com/zywu/p/5758917.html">参考</a></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">reConstructBinaryTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pre</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">in</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 检查输入的正确性</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pre</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">in</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">pre</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">in</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">construct</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="n">pre</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">pre</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="nl">public:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">construct</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pre</span><span class="p">,</span><span class="kt">int</span> <span class="n">ps</span><span class="p">,</span><span class="kt">int</span> <span class="n">pe</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">in</span><span class="p">,</span><span class="kt">int</span> <span class="n">is</span><span class="p">,</span><span class="kt">int</span> <span class="n">ie</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ps</span> <span class="o">&gt;</span> <span class="n">pe</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="c1">// 取前序遍历第一个是根节点</span>
        <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">pre</span><span class="p">[</span><span class="n">ps</span><span class="p">];</span>
        <span class="c1">// 在中序中找根节点</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ie</span> <span class="o">&amp;&amp;</span> <span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">value</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 如果没有找到，则输入不合法，抛出异常</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">ie</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="c1">// 创建当前根节点，并赋值</span>
        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">FinalTree</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
        <span class="c1">// 递归调用当前节点的左子树</span>
        <span class="n">FinalTree</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">construct</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">ps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ps</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="n">is</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="n">is</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="c1">// 递归当前调用节点的右子树</span>
        <span class="n">FinalTree</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">construct</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">ps</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="n">is</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pe</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ie</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">FinalTree</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="8-树-二叉树的下一个节点">8 树-二叉树的下一个节点<a href="#8-树-二叉树的下一个节点" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ol><li>如果节点有右子节点，则右子节点的最左节点是该节点的下一个节点<li>如果节点无右子节点，但该节点是其父节点的左子节点，则父节点是该节点的下一个节点<li>如果节点无右子节点，且该节点是其父节点的右子节点，则沿着父节点向上遍历，满足XXX的父节点是其该节点的下一个节点</ol><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="n">TreeNode</span><span class="o">*</span> <span class="nf">GetNext</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">pNode</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">pNext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="c1">// 有右子树</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pNode</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">pNode</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="n">pNext</span> <span class="o">=</span> <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="k">else</span> <span class="n">pNext</span> <span class="o">=</span> <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 无右子树，有父节点</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pNode</span><span class="o">-&gt;</span><span class="n">par</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">TreeNode</span><span class="o">*</span><span class="n">pCurrent</span> <span class="o">=</span> <span class="n">pNode</span><span class="p">;</span>
        <span class="n">TreeNode</span><span class="o">*</span><span class="n">pParent</span> <span class="o">=</span> <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">par</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">pParent</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">pParent</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="n">pCurrent</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">pCurrent</span> <span class="o">=</span> <span class="n">pParent</span><span class="p">;</span>
            <span class="n">pParent</span> <span class="o">=</span> <span class="n">pCurrent</span><span class="o">-&gt;</span><span class="n">par</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">pNext</span> <span class="o">=</span> <span class="n">pParent</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">pNext</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="9-栈和队列-用两个栈实现队列">9 栈和队列-用两个栈实现队列<a href="#9-栈和队列-用两个栈实现队列" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ol><li>先将树压入第一个栈<li>将第一个栈元素pop出，push进第二个栈<li>第二个栈就是队列的顺序</ol><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">temple</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">stack2</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">temple</span><span class="o">=</span><span class="n">stack2</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">stack2</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">stack1</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">temple</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">stack1</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">pop</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">temple</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">stack1</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">temple</span><span class="o">=</span><span class="n">stack1</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">stack1</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">stack2</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">temple</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">temple</span><span class="o">=</span><span class="n">stack2</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
    <span class="n">stack2</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">temple</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="10-斐波那契数">10 斐波那契数<a href="#10-斐波那契数" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>循环方法实现计算<ul><li>时间复杂度<code class="language-plaintext highlighter-rouge">O(n)</code></ul><li><a href="https://www.jianshu.com/p/965d12083d7f">青蛙跳台阶问题</a></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kt">long</span> <span class="kt">long</span> <span class="nf">Fibonacci</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span><span class="mi">1</span> <span class="p">};</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>

    <span class="kt">long</span> <span class="kt">long</span> <span class="n">fibFront</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">fibBack</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">fibN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">fibN</span> <span class="o">=</span> <span class="n">fibFront</span> <span class="o">+</span> <span class="n">fibBack</span><span class="p">;</span>

        <span class="n">fibFront</span> <span class="o">=</span> <span class="n">fibBack</span><span class="p">;</span>
        <span class="n">fibBack</span> <span class="o">=</span> <span class="n">fibN</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">fibN</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="排序-快排">排序-快排<a href="#排序-快排" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ol><li>指定最左端的数为 pivot<li>左指针找第一个大于 pivot 的数<li>右指针找第一个小于 pivot 的数<li>交换两个数<li>大于begin的数都在右，小于的都在左</ol><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">QuickSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">left</span><span class="p">,</span><span class="kt">int</span> <span class="n">right</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">)</span> <span class="p">{</span> <span class="n">i</span><span class="o">++</span><span class="p">;}</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">)</span> <span class="p">{</span> <span class="n">j</span><span class="o">--</span><span class="p">;}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
            <span class="n">j</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="n">QuickSort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">left</span><span class="p">)</span> <span class="n">QuickSort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="排序-归并">排序-归并<a href="#排序-归并" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ol><li>递归<li>合并两个数组的函数<li>二分排序</ol><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">Merge</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 获取左右部分数组的大小（实际还是原数组）</span>
    <span class="kt">int</span> <span class="n">l_c</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">r_c</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">m</span><span class="p">;</span>
    
    <span class="c1">// 将数组值赋给临时数组（两个数组）</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">L</span><span class="p">(</span><span class="n">l_c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">R</span><span class="p">(</span><span class="n">r_c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">l_c</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">r_c</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">j</span><span class="p">];</span>

    <span class="c1">// 每个数组的最后一个数赋值11111111,任意数与之比较都小</span>
    <span class="n">L</span><span class="p">[</span><span class="n">l_c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">11111111</span><span class="p">;</span>
    <span class="n">R</span><span class="p">[</span><span class="n">r_c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">11111111</span><span class="p">;</span>

    <span class="c1">// </span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
        <span class="k">else</span>
            <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">MergeSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">MergeSort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
        <span class="n">MergeSort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
        <span class="n">Merge</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="排序-堆排">排序-堆排<a href="#排序-堆排" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ol><li>原则<ol><li>符合完全二叉树<li>父节点大于孩子节点</ol><li>步骤<ol><li>构建最大堆–插入构建<li>删除首个-&gt;下面的顺次移位</ol></ol><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">insert_p</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">parent</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">p</span><span class="p">])</span>
        <span class="c1">// if(a[parent] &gt; a[p])</span>
        <span class="p">{</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">parent</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">p</span><span class="p">]);</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">delete_max</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// 找出最大的</span>
    <span class="c1">// large指向已遍历的最大值</span>
    <span class="c1">// index指向当前空缺位置</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="n">length</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">else</span> 
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">large</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">?</span> <span class="n">left</span> <span class="o">:</span> <span class="n">right</span><span class="p">;</span>
            <span class="n">a</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">large</span><span class="p">];</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">large</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">a</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">length</span><span class="p">];</span>
    <span class="n">a</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>

<span class="p">}</span>

<span class="kt">void</span> <span class="nf">HeapSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">insert_p</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">)</span>
        <span class="n">delete_max</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="11-查找-找出旋转数组的最小数字">11 查找-找出旋转数组的最小数字<a href="#11-查找-找出旋转数组的最小数字" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ol><li>二分法、双指针<li>中间与左、右的值都相等时，采用顺序遍历 <code class="language-plaintext highlighter-rouge">MinInOrder</code></ol><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">MinInOrder</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">FindMin_Rotate</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">a</span><span class="p">[</span><span class="n">right</span><span class="p">])</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="c1">// 若left、mid、right三个指针指的数都相同，则用顺序查找</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">MinInOrder</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">a</span><span class="p">[</span><span class="n">left</span><span class="p">])</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="p">[</span><span class="n">right</span><span class="p">])</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">];</span>    
<span class="p">}</span>
</pre></table></code></div></div><h2 id="12-回溯法-矩阵中的路径">12 回溯法-矩阵中的路径<a href="#12-回溯法-矩阵中的路径" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>判断数组中是否含有相应字符串</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="nf">haspath</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">matrix</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span><span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 判断二维数组是否合法</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">matrix</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">rows</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">cols</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="c1">// 创建访问标志的数组,置为0/false</span>
    <span class="kt">bool</span><span class="o">*</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">bool</span><span class="p">[</span><span class="n">rows</span><span class="o">*</span><span class="n">cols</span><span class="p">];</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">visited</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rows</span><span class="o">*</span><span class="n">cols</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">pathLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// 在二维数组内循环</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">row</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="p">;</span><span class="n">row</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">col</span> <span class="o">&lt;</span> <span class="n">cols</span><span class="p">;</span><span class="n">col</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">haspathcore</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">delete</span><span class="p">[]</span> <span class="n">visited</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">haspathcore</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">matrix</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">pathLength</span><span class="p">,</span> <span class="kt">bool</span><span class="o">*</span> <span class="n">visited</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 读取到str最后，则返回true</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">pathLength</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">haspath</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">cols</span>
        <span class="o">&amp;&amp;</span><span class="n">matrix</span><span class="p">[</span><span class="n">row</span><span class="o">*</span><span class="n">cols</span> <span class="o">+</span> <span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="n">str</span><span class="p">[</span><span class="n">pathLength</span><span class="p">]</span> 
        <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">row</span><span class="o">*</span><span class="n">cols</span> <span class="o">+</span> <span class="n">col</span><span class="p">])</span>
    <span class="p">{</span>
        <span class="n">pathLength</span><span class="o">++</span><span class="p">;</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">row</span><span class="o">*</span><span class="n">cols</span> <span class="o">+</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="c1">// 在其上下左右四个方向查找</span>
        <span class="n">haspath</span> <span class="o">=</span> <span class="n">haspathcore</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">pathLength</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
            <span class="o">||</span> <span class="n">haspathcore</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">pathLength</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
            <span class="o">||</span> <span class="n">haspathcore</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">pathLength</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
            <span class="o">||</span> <span class="n">haspathcore</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">pathLength</span><span class="p">,</span> <span class="n">visited</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">haspath</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="o">--</span><span class="n">pathLength</span><span class="p">;</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">row</span><span class="o">*</span><span class="n">cols</span> <span class="o">+</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">haspath</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="14-动态规划-剪绳子">14 动态规划-剪绳子<a href="#14-动态规划-剪绳子" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ol><li>至少被分成2段<li>求各段最大乘积<li>动态规划<li>贪心算法，<code class="language-plaintext highlighter-rouge">n&gt;=5</code>时，讨论情况 <code class="language-plaintext highlighter-rouge">O(1)</code></ol><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre><td class="rouge-code"><pre><span class="c1">// 动态规划</span>
<span class="kt">int</span> <span class="nf">max_cut</span><span class="p">(</span><span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 排除三个特殊示例</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>

    <span class="c1">// 初始化新的数组</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">max</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;=</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>   
            <span class="c1">// 寻找最大</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">max</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">max</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

            <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="n">length</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// 贪心算法</span>
<span class="kt">int</span> <span class="nf">max1_cut</span><span class="p">(</span><span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 排除三个特殊示例</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>

    <span class="c1">// 能够减3的次数</span>
    <span class="kt">int</span> <span class="n">count_3</span> <span class="o">=</span> <span class="n">length</span> <span class="o">/</span> <span class="mi">3</span><span class="p">;</span>

    <span class="c1">// 余数为1时，则少减一次，4=2*2</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">count_3</span><span class="o">--</span><span class="p">;</span>

    <span class="c1">// 能够除以2的次数</span>
    <span class="kt">int</span> <span class="n">count_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">length</span> <span class="o">-</span> <span class="n">count_3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">count_3</span><span class="p">)</span><span class="o">*</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">count_2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="15-位运算-二进制中1的个数">15 位运算-二进制中1的个数<a href="#15-位运算-二进制中1的个数" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">count_1</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="对应剑指offer第三章-高质量的代码">对应剑指offer第三章-高质量的代码<a href="#对应剑指offer第三章-高质量的代码" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ol><li>规范性<ul><li>书写清晰<li>布局合理<li>命名合理</ul><li>完整性<ul><li>完成基本功能<li>考虑边界条件<li>做好错误处理</ul><li>鲁棒性<ul><li>采取防御性编程<li>处理无效输入</ul></ol><h2 id="16-数值的整数次方">16 数值的整数次方<a href="#16-数值的整数次方" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ol><li>位运算的适用范围仅仅是整数<li>递归算法适用负数</ol><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="c1">// 位运算</span>
<span class="kt">int</span> <span class="nf">pow_test</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">sum</span> <span class="o">*=</span> <span class="n">temp</span><span class="p">;</span>

        <span class="n">n</span><span class="o">=</span><span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">temp</span> <span class="o">*=</span> <span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sum</span> <span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 递归</span>
<span class="kt">double</span> <span class="nf">pow_try</span><span class="p">(</span><span class="kt">double</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="mf">1.0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">m</span><span class="p">;</span>

    <span class="kt">double</span> <span class="n">base</span> <span class="o">=</span> <span class="n">pow_try</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">base</span> <span class="o">*=</span> <span class="n">base</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">base</span> <span class="o">*=</span> <span class="n">m</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">base</span><span class="p">;</span>    
<span class="p">}</span>
</pre></table></code></div></div><h2 id="17-打印-1-最大的n位数">17 打印 1-最大的n位数<a href="#17-打印-1-最大的n位数" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>难点：大数–需要将数转化为字符串</ul><h2 id="18-删除连续的重复数-链表">18 删除连续的重复数-链表<a href="#18-删除连续的重复数-链表" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">deleteDuplication</span><span class="p">(</span><span class="n">ListNode</span><span class="o">**</span> <span class="n">pHead</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pHead</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="o">*</span><span class="n">pHead</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="n">ListNode</span><span class="o">*</span> <span class="n">pPre</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">pCur</span> <span class="o">=</span> <span class="o">*</span><span class="n">pHead</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">pCur</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">pNex</span> <span class="o">=</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">n_next</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">needDelete</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pNex</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="o">&amp;&amp;</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">n_value</span> <span class="o">==</span> <span class="n">pNex</span><span class="o">-&gt;</span><span class="n">n_value</span><span class="p">)</span>
            <span class="n">needDelete</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">needDelete</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">pPre</span> <span class="o">=</span> <span class="n">pCur</span><span class="p">;</span>
            <span class="n">pCur</span> <span class="o">=</span> <span class="n">pNex</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">n_value</span><span class="p">;</span>
            <span class="n">ListNode</span><span class="o">*</span> <span class="n">pTobeDel</span> <span class="o">=</span> <span class="n">pCur</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">pTobeDel</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="o">&amp;&amp;</span><span class="n">pTobeDel</span><span class="o">-&gt;</span><span class="n">n_value</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">pNex</span> <span class="o">=</span> <span class="n">pTobeDel</span><span class="o">-&gt;</span><span class="n">n_next</span><span class="p">;</span>

                <span class="k">delete</span> <span class="n">pTobeDel</span><span class="p">;</span>
                <span class="n">pTobeDel</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

                <span class="n">pTobeDel</span> <span class="o">=</span> <span class="n">pNex</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// 若指针头就是重复，且被删除，后面无后续数字，则</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pPre</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
                <span class="o">*</span><span class="n">pHead</span> <span class="o">=</span> <span class="n">pNex</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">pPre</span><span class="o">-&gt;</span><span class="n">n_next</span> <span class="o">=</span> <span class="n">pNex</span><span class="p">;</span>
            <span class="n">pCur</span> <span class="o">=</span> <span class="n">pNex</span><span class="p">;</span>
        <span class="p">}</span>
        
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="21-调整数组使奇数在前偶数在后">21 调整数组，使奇数在前，偶数在后<a href="#21-调整数组使奇数在前偶数在后" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>借鉴快排的方法<li>可以将<code class="language-plaintext highlighter-rouge">(a[i] &amp; 1) == 1</code>转换成一个函数<code class="language-plaintext highlighter-rouge">fun(n)</code>，增强其泛化能力</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">changearray</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// int tmp = a[0];</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="n">i</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">while</span> <span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">j</span><span class="o">--</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"i is "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="s">"j is "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
            <span class="n">j</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>    
<span class="p">}</span>
</pre></table></code></div></div><h2 id="22-链表中倒数第k个节点">22 链表中倒数第K个节点<a href="#22-链表中倒数第k个节点" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>双指针<li>第一个指针到（k-1）时，第二个与第一个开始同步前进<li>增加测试样例，提高鲁棒性</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="n">ListNode</span><span class="o">*</span> <span class="nf">FindKthNode</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span><span class="n">pListHead</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pListHead</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">ANode</span> <span class="o">=</span> <span class="n">pListHead</span><span class="p">;</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">BNode</span> <span class="o">=</span> <span class="n">ANode</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">ANode</span> <span class="o">=</span> <span class="n">ANode</span><span class="o">-&gt;</span><span class="n">n_next</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">ANode</span><span class="o">-&gt;</span><span class="n">n_next</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ANode</span> <span class="o">=</span> <span class="n">ANode</span><span class="o">-&gt;</span><span class="n">n_next</span><span class="p">;</span>
        <span class="n">BNode</span> <span class="o">=</span> <span class="n">BNode</span><span class="o">-&gt;</span><span class="n">n_next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">BNode</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="23-链表中环的入口节点">23 链表中环的入口节点<a href="#23-链表中环的入口节点" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>先判断是否有环：双指针，一快一慢，快的追上慢的，则有环<li>找入口：双指针，第一个比第二个多环的节点数n<h2 id="24-反转链表">24 反转链表<a href="#24-反转链表" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="n">ListNode</span><span class="o">*</span> <span class="nf">ReverseList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">pHead</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 定义三个循环节点</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">pre</span><span class="p">;</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">curr</span><span class="p">;</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">follow</span><span class="p">;</span>
    
    <span class="c1">// 初始化</span>
    <span class="n">pre</span> <span class="o">=</span> <span class="n">pHead</span><span class="p">;</span>
    <span class="n">curr</span> <span class="o">=</span> <span class="n">pHead</span><span class="o">-&gt;</span><span class="n">n_next</span><span class="p">;</span>
    <span class="n">follow</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">n_next</span><span class="p">;</span>
    
    <span class="c1">// 循环，每次改变一个节点的指针方向</span>
    <span class="n">pHead</span><span class="o">-&gt;</span><span class="n">n_next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">follow</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">curr</span><span class="o">-&gt;</span><span class="n">n_next</span> <span class="o">=</span> <span class="n">pre</span><span class="p">;</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">follow</span><span class="p">;</span>
        <span class="n">follow</span> <span class="o">=</span> <span class="n">follow</span><span class="o">-&gt;</span><span class="n">n_next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">curr</span><span class="o">-&gt;</span><span class="n">n_next</span> <span class="o">=</span> <span class="n">pre</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="25-合并两个排序好的链表">25 合并两个排序好的链表<a href="#25-合并两个排序好的链表" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="n">ListNode</span><span class="o">*</span><span class="nf">Merge</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">pHead1</span><span class="p">,</span> <span class="n">ListNode</span><span class="o">*</span> <span class="n">pHead2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pHead1</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pHead2</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pHead2</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pHead1</span><span class="p">;</span>

    <span class="n">ListNode</span><span class="o">*</span> <span class="n">MergedHead</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pHead1</span><span class="o">-&gt;</span><span class="n">n_next</span> <span class="o">&lt;</span> <span class="n">pHead2</span><span class="o">-&gt;</span><span class="n">n_next</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">MergedHead</span> <span class="o">=</span> <span class="n">pHead1</span><span class="p">;</span>
        <span class="n">MergedHead</span><span class="o">-&gt;</span><span class="n">n_next</span> <span class="o">=</span> <span class="n">Merge</span><span class="p">(</span><span class="n">pHead1</span><span class="o">-&gt;</span><span class="n">n_next</span><span class="p">,</span><span class="n">pHead2</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">MergedHead</span> <span class="o">=</span> <span class="n">pHead2</span><span class="p">;</span>
        <span class="n">MergedHead</span><span class="o">-&gt;</span><span class="n">n_next</span> <span class="o">=</span> <span class="n">Merge</span><span class="p">(</span><span class="n">pHead1</span><span class="p">,</span><span class="n">pHead2</span><span class="o">-&gt;</span><span class="n">n_next</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">MergedHead</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="26-判断b是否是a的子结构-树">26 判断B是否是A的子结构-树<a href="#26-判断b是否是a的子结构-树" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>子树不单单只有两层<li>若树的值不是int型，则不能直接用等号判断大小</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="nf">a_include_b</span><span class="p">(</span><span class="n">BinaryTree</span><span class="o">*</span> <span class="n">father</span><span class="p">,</span> <span class="n">BinaryTree</span><span class="o">*</span> <span class="n">son</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">son</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">father</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">father</span><span class="o">-&gt;</span><span class="n">p_value</span> <span class="o">!=</span> <span class="n">son</span><span class="o">-&gt;</span><span class="n">p_value</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">a_include_b</span><span class="p">(</span><span class="n">father</span><span class="o">-&gt;</span><span class="n">p_left</span><span class="p">,</span> <span class="n">son</span><span class="o">-&gt;</span><span class="n">p_left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">a_include_b</span><span class="p">(</span><span class="n">father</span><span class="o">-&gt;</span><span class="n">p_right</span><span class="p">,</span> <span class="n">son</span><span class="o">-&gt;</span><span class="n">p_right</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">SonTree</span><span class="p">(</span><span class="n">BinaryTree</span><span class="o">*</span> <span class="n">father</span><span class="p">,</span> <span class="n">BinaryTree</span><span class="o">*</span> <span class="n">son</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">father</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span><span class="n">son</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">father</span><span class="o">-&gt;</span><span class="n">p_value</span> <span class="o">==</span> <span class="n">son</span><span class="o">-&gt;</span><span class="n">p_value</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">a_include_b</span><span class="p">(</span><span class="n">father</span><span class="p">,</span> <span class="n">son</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">SonTree</span><span class="p">(</span><span class="n">father</span><span class="o">-&gt;</span><span class="n">p_left</span><span class="p">,</span> <span class="n">son</span><span class="p">);</span>

        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">SonTree</span><span class="p">(</span><span class="n">father</span><span class="o">-&gt;</span><span class="n">p_right</span><span class="p">,</span> <span class="n">son</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="对应剑指offer第四章解决面试题的思路">对应剑指offer第四章–解决面试题的思路<a href="#对应剑指offer第四章解决面试题的思路" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ol><li>抽象问题具体化<ul><li>画图<li>举例</ul><li>分解让复杂问题简单化</ol><h2 id="27-二叉树的镜像">27 二叉树的镜像<a href="#27-二叉树的镜像" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>树不一定必须是完全二叉树<li>自上而下，自左而右</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="c1">// 二叉树的镜像</span>
<span class="c1">// // 树的申明</span>
<span class="k">struct</span> <span class="nc">BinaryTree</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">b_value</span><span class="p">;</span>
    <span class="n">BinaryTree</span><span class="o">*</span> <span class="n">b_left</span><span class="p">;</span>
    <span class="n">BinaryTree</span><span class="o">*</span> <span class="n">b_right</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// // 函数</span>
<span class="kt">void</span> <span class="nf">MirrorBinTree</span><span class="p">(</span><span class="n">BinaryTree</span><span class="o">*</span> <span class="n">pNode</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pNode</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pNode</span><span class="o">-&gt;</span><span class="n">b_left</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="o">&amp;&amp;</span><span class="n">pNode</span><span class="o">-&gt;</span><span class="n">b_right</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    
    <span class="n">BinaryTree</span><span class="o">*</span> <span class="n">pTemp</span> <span class="o">=</span> <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">b_left</span><span class="p">;</span>
    <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">b_left</span> <span class="o">=</span> <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">b_right</span><span class="p">;</span>
    <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">b_right</span> <span class="o">=</span> <span class="n">pTemp</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pNode</span><span class="o">-&gt;</span><span class="n">b_left</span><span class="p">)</span>
        <span class="n">MirrorBinTree</span><span class="p">(</span><span class="n">pNode</span><span class="o">-&gt;</span><span class="n">b_left</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pNode</span><span class="o">-&gt;</span><span class="n">b_right</span><span class="p">)</span>
        <span class="n">MirrorBinTree</span><span class="p">(</span><span class="n">pNode</span><span class="o">-&gt;</span><span class="n">b_right</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="28-对称二叉树">28 对称二叉树<a href="#28-对称二叉树" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>判断二叉树是不是对称<li>如果二叉树的镜像和本身一样,则是对称二叉树<li>前序遍历和对称前序遍历,需要考虑空指针的情况</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c1">// 对称二叉树</span>
<span class="c1">// // 初次输入时两个root相同</span>
<span class="kt">bool</span> <span class="nf">isSym</span><span class="p">(</span><span class="n">BinaryTree</span><span class="o">*</span> <span class="n">root1</span><span class="p">,</span> <span class="n">BinaryTree</span><span class="o">*</span> <span class="n">root2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root1</span> <span class="o">==</span><span class="nb">nullptr</span><span class="o">&amp;&amp;</span> <span class="n">root2</span><span class="o">==</span><span class="nb">nullptr</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root1</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="o">||</span> <span class="n">root2</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">root1</span><span class="o">-&gt;</span><span class="n">b_value</span> <span class="o">!=</span> <span class="n">root2</span><span class="o">-&gt;</span><span class="n">b_value</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">isSym</span><span class="p">(</span><span class="n">root1</span><span class="o">-&gt;</span><span class="n">b_left</span><span class="p">,</span> <span class="n">root2</span><span class="o">-&gt;</span><span class="n">b_right</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isSym</span><span class="p">(</span><span class="n">root1</span><span class="o">-&gt;</span><span class="n">b_right</span><span class="p">,</span> <span class="n">root1</span><span class="o">-&gt;</span><span class="n">b_left</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="29-顺序打印矩阵">29 顺序打印矩阵<a href="#29-顺序打印矩阵" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ol><li>取左上角的元素为 start<li>边界条件为 <code class="language-plaintext highlighter-rouge">col&gt;2start &amp;&amp; row&gt;2start</code><li>每次打印一圈<h2 id="30-包含min函数的栈">30 包含min函数的栈<a href="#30-包含min函数的栈" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>用辅助栈实现最小栈的功能</ul></ol><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">StackWithMin</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">StackWithMin</span><span class="p">()</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">StackWithMin</span><span class="p">()</span> <span class="p">{}</span>

    <span class="n">T</span><span class="o">&amp;</span> <span class="n">top</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">top</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">pop</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">min</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="nl">private:</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>   <span class="n">m_data</span><span class="p">;</span>     <span class="c1">// 数据栈，存放栈的所有元素</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>   <span class="n">m_min</span><span class="p">;</span>      <span class="c1">// 辅助栈，存放栈的最小元素</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="n">StackWithMin</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">push</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_data</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m_min</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">m_min</span><span class="p">.</span><span class="n">top</span><span class="p">())</span>
        <span class="n">m_min</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">m_min</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">m_min</span><span class="p">.</span><span class="n">top</span><span class="p">());</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="n">StackWithMin</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">pop</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_min</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="n">m_data</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span>  <span class="n">StackWithMin</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">m_data</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">m_min</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="31-栈的压入弹出序列">31 栈的压入、弹出序列<a href="#31-栈的压入弹出序列" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>判断输出结构是否能有入栈顺序得出<li>如果下一个弹出的数字刚好是栈顶，则直接弹出，否则就压栈将待弹出树压到栈顶</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="nf">isPopOrder</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pPush</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pPop</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pPush</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">pPop</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">stc</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">pPush</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">stc</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">pPush</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">j</span><span class="o">&lt;</span><span class="n">pPop</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&amp;&amp;</span><span class="n">stc</span><span class="p">.</span><span class="n">top</span><span class="p">()</span><span class="o">==</span><span class="n">pPop</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="n">stc</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">stc</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>  <span class="c1">// 通过判断栈是否为空，来判断是否是输出</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="32-层序遍历二叉树并按层输出">32 层序遍历二叉树，并按层输出<a href="#32-层序遍历二叉树并按层输出" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>每层添加标志，每打印一次，toBePrinted减1<li>每压栈一次，nextlevelsize加1</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">Print</span><span class="p">(</span><span class="n">BinaryTree</span><span class="o">*</span> <span class="n">pRoot</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="n">BinaryTree</span><span class="o">*&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">pRoot</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">toBePrinted</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">nextLevelSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">BinaryTree</span><span class="o">*</span> <span class="n">print_one</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">print_one</span><span class="o">-&gt;</span><span class="n">b_value</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">print_one</span><span class="o">-&gt;</span><span class="n">b_left</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">print_one</span><span class="o">-&gt;</span><span class="n">b_left</span><span class="p">);</span>
            <span class="n">nextLevelSize</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
            
        <span class="k">if</span> <span class="p">(</span><span class="n">print_one</span><span class="o">-&gt;</span><span class="n">b_right</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">print_one</span><span class="o">-&gt;</span><span class="n">b_right</span><span class="p">);</span>
            <span class="n">nextLevelSize</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">toBePrinted</span><span class="o">--</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">toBePrinted</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
            <span class="n">toBePrinted</span> <span class="o">=</span> <span class="n">nextLevelSize</span><span class="p">;</span>
            <span class="n">nextLevelSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="33-判断是不是二叉搜索树的后序遍历">33 判断是不是二叉搜索树的后序遍历<a href="#33-判断是不是二叉搜索树的后序遍历" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ol><li>先找根节点<li>再分左右子节点<li>左子树都小于根节点，右子树都小于根节点<ul><li>思路是先假定是后序遍历，检测它符合二叉搜索树的条件</ul></ol><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="nf">sequenceofBST</span><span class="p">(</span><span class="kt">int</span> <span class="n">sequence</span><span class="p">[],</span><span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sequence</span><span class="o">==</span><span class="nb">nullptr</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">root</span> <span class="o">=</span> <span class="n">sequence</span><span class="p">[</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// 找左子树</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sequence</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">root</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 右子树都大于root</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">--</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sequence</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">root</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 判断左子树是否为BTS</span>
    <span class="kt">bool</span> <span class="n">left</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">sequenceofBST</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

    <span class="c1">// 判断右子树是否为BFS</span>
    <span class="kt">bool</span> <span class="n">right</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">sequenceofBST</span><span class="p">(</span><span class="n">sequence</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">right</span><span class="o">&amp;&amp;</span><span class="n">left</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="34-二叉树中和为某一值的路径">34 二叉树中和为某一值的路径<a href="#34-二叉树中和为某一值的路径" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ol><li>判断是否是叶子节点<li>判断所有的和是不是相等<li>打印路径时候需要访问每个元素，遂用vector实现栈的功能</ol><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="c1">// currentSum 初始化为0</span>
<span class="kt">void</span> <span class="nf">FindPath</span><span class="p">(</span><span class="n">BinaryTree</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Sum</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">currentSum</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">currentSum</span> <span class="o">+=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">b_value</span><span class="p">;</span>
    <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">b_value</span><span class="p">);</span>

    <span class="c1">// 判断是否是叶节点，是否和相同</span>
    <span class="kt">bool</span> <span class="n">ifLeaf</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">b_left</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="o">&amp;&amp;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">b_right</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">currentSum</span> <span class="o">==</span> <span class="n">Sum</span> <span class="o">&amp;&amp;</span> <span class="n">ifLeaf</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"A path is found </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(;</span><span class="n">it</span> <span class="o">!=</span> <span class="n">path</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="n">it</span><span class="o">++</span><span class="p">)</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 若不是叶节点，遍历子节点</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">b_left</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="n">FindPath</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Sum</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">currentSum</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">b_right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="n">FindPath</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Sum</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">currentSum</span><span class="p">);</span>

    <span class="c1">// 每次都肯定会返回父节点，则要弹出最后一位</span>
    <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="35-复杂链表的复制">35 复杂链表的复制<a href="#35-复杂链表的复制" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>方法一：先复制，再挨个从链表头部找pSibiling，时间负责都为O(n^2)<li>方法二: 空间复杂度换时间复杂度,利用哈希表,建立复制前后链表之间的联系<li>方法三: 将复制的放在被复制的后面,则不需要空间消耗:A,A’,B,B’</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre><td class="rouge-code"><pre><span class="c1">// 复制链表，插空连接</span>
<span class="kt">void</span> <span class="nf">CloneNodes</span><span class="p">(</span><span class="n">complexListNode</span><span class="o">*</span> <span class="n">pHead</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">complexListNode</span><span class="o">*</span> <span class="n">pNode</span> <span class="o">=</span> <span class="n">pHead</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">pNode</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">complexListNode</span><span class="o">*</span> <span class="n">pCloned</span> <span class="o">=</span> <span class="k">new</span> <span class="n">complexListNode</span><span class="p">();</span>
        <span class="n">pCloned</span><span class="o">-&gt;</span><span class="n">p_value</span> <span class="o">=</span> <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">p_value</span><span class="p">;</span>
        <span class="n">pCloned</span><span class="o">-&gt;</span><span class="n">p_next</span> <span class="o">=</span> <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">p_next</span><span class="p">;</span>
        <span class="n">pCloned</span><span class="o">-&gt;</span><span class="n">p_sibiling</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

        <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">p_next</span> <span class="o">=</span> <span class="n">pCloned</span><span class="p">;</span>

        <span class="n">pNode</span> <span class="o">=</span> <span class="n">pCloned</span><span class="o">-&gt;</span><span class="n">p_next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 设置p_sibiling</span>
<span class="kt">void</span> <span class="nf">connectSibilingNodes</span><span class="p">(</span><span class="n">complexListNode</span><span class="o">*</span> <span class="n">pHead</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">complexListNode</span><span class="o">*</span> <span class="n">pNode</span> <span class="o">=</span> <span class="n">pHead</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">pNode</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">complexListNode</span><span class="o">*</span> <span class="n">pCloned</span> <span class="o">=</span> <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">p_next</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pNode</span><span class="o">-&gt;</span><span class="n">p_sibiling</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
            <span class="n">pCloned</span><span class="o">-&gt;</span><span class="n">p_sibiling</span> <span class="o">=</span> <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">p_sibiling</span><span class="o">-&gt;</span><span class="n">p_next</span><span class="p">;</span>

        <span class="n">pNode</span> <span class="o">=</span> <span class="n">pCloned</span><span class="o">-&gt;</span><span class="n">p_next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 把长链表分成两个链表，奇数偶数</span>
<span class="n">complexListNode</span><span class="o">*</span> <span class="nf">ReconectedNodes</span><span class="p">(</span><span class="n">complexListNode</span><span class="o">*</span> <span class="n">pHead</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">complexListNode</span><span class="o">*</span> <span class="n">pNode</span> <span class="o">=</span> <span class="n">pHead</span><span class="p">;</span>
    <span class="n">complexListNode</span><span class="o">*</span> <span class="n">pClondeHead</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">complexListNode</span><span class="o">*</span> <span class="n">pClonedNode</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

    <span class="c1">// 构建克隆链表的链表头</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pNode</span><span class="o">!=</span><span class="nb">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">pClondeHead</span> <span class="o">=</span> <span class="n">pClonedNode</span> <span class="o">=</span> <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">p_next</span><span class="p">;</span>
        <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">p_next</span> <span class="o">=</span> <span class="n">pClonedNode</span><span class="o">-&gt;</span><span class="n">p_next</span><span class="p">;</span>
        <span class="n">pNode</span> <span class="o">=</span> <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">p_next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 循环分开两个链表</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">pNode</span><span class="o">!=</span><span class="nb">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">pClonedNode</span><span class="o">-&gt;</span><span class="n">p_next</span> <span class="o">=</span> <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">p_next</span><span class="p">;</span>
        <span class="n">pClonedNode</span> <span class="o">=</span> <span class="n">pClonedNode</span><span class="o">-&gt;</span><span class="n">p_next</span><span class="p">;</span>
        <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">p_next</span> <span class="o">=</span> <span class="n">pClonedNode</span><span class="o">-&gt;</span><span class="n">p_next</span><span class="p">;</span>
        <span class="n">pNode</span> <span class="o">=</span> <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">p_next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">pClonedNode</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="38-字符串的排列">38 字符串的排列<a href="#38-字符串的排列" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>思路:固定第一个,找下面的排序可能<li>实现:使用递归</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">Permutation</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">pStr</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pBegin</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pBegin</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pStr</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">pCh</span> <span class="o">=</span> <span class="n">pBegin</span><span class="p">;</span><span class="o">*</span><span class="n">pCh</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">;</span><span class="n">pCh</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 列出所有可能的头部</span>
            <span class="c1">// 通过将第一个与后面的顺次交换</span>
            <span class="kt">char</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">pCh</span><span class="p">;</span>
            <span class="o">*</span><span class="n">pCh</span> <span class="o">=</span> <span class="o">*</span><span class="n">pBegin</span><span class="p">;</span>
            <span class="o">*</span><span class="n">pBegin</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>

            <span class="c1">// 定好第一个数，在递归进行下一个数的确定</span>
            <span class="n">Permutation</span><span class="p">(</span><span class="n">pStr</span><span class="p">,</span> <span class="n">pBegin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

            <span class="c1">// 恢复成初始的字符状态</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">pCh</span><span class="p">;</span>
            <span class="o">*</span><span class="n">pCh</span> <span class="o">=</span> <span class="o">*</span><span class="n">pBegin</span><span class="p">;</span>
            <span class="o">*</span><span class="n">pBegin</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>

        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="39-数组中出现次数超过一半的数字">39 数组中出现次数超过一半的数字<a href="#39-数组中出现次数超过一半的数字" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>基于快排,但基于的数在middle位置的时候,即为此数<h2 id="40-最小的k个数">40 最小的K个数<a href="#40-最小的k个数" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ol><li>修改数组–类似于快排的思路<li>最小堆的思路</ol></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">insert_p</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">parent</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">p</span><span class="p">])</span>
        <span class="c1">// if (a[parent] &lt; a[p])</span>
        <span class="p">{</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">parent</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">p</span><span class="p">]);</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">delete_min</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// 找出最大的</span>
    <span class="c1">// large指向已遍历的最大值</span>
    <span class="c1">// index指向当前空缺位置</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="n">length</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">small</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">?</span> <span class="n">right</span> <span class="o">:</span> <span class="n">left</span><span class="p">;</span>
            <span class="n">a</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">small</span><span class="p">];</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">small</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">a</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">length</span><span class="p">];</span>
    <span class="n">a</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>

<span class="p">}</span>

<span class="kt">void</span> <span class="nf">HeapSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">insert_p</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">4</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">)</span>
        <span class="n">delete_min</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">myints</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">45</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">32</span> <span class="p">};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="n">myints</span><span class="p">,</span> <span class="n">myints</span> <span class="o">+</span> <span class="mi">9</span><span class="p">);</span>
    <span class="n">HeapSort</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">4</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    
    <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="41-数据流的中位数">41 数据流的中位数<a href="#41-数据流的中位数" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ol><li>使用最大堆和最小堆的方式来实现<li>数据均分为两部分,a为最大堆的堆顶,b为最小堆的堆顶<li>确保a&lt;b,即最小堆的所有数大于最大堆的所有数<ul><li>插入min中的数,若比<code class="language-plaintext highlighter-rouge">max[0]</code>小,则先取max中的最大值 插入max中的数,若比<code class="language-plaintext highlighter-rouge">min[0]</code>大,则先取min中的最小值</ul></ol><h2 id="二叉树数的相关知识">二叉树数的相关知识<a href="#二叉树数的相关知识" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">BinTree</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">BinTree</span> <span class="o">*</span><span class="n">leftChild</span><span class="p">;</span>
    <span class="n">BinTree</span> <span class="o">*</span><span class="n">rightChild</span><span class="p">;</span>
    <span class="n">BinTree</span><span class="p">()</span> <span class="p">{</span> <span class="n">leftChild</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">rightChild</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 通过递归构建二叉树</span>
<span class="n">BinTree</span> <span class="o">*</span><span class="nf">CreateBinTree</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">BinTree</span> <span class="o">*</span><span class="n">T</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">T</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinTree</span><span class="p">();</span><span class="c1">// 初始化</span>
        <span class="n">T</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
        <span class="n">T</span><span class="o">-&gt;</span><span class="n">leftChild</span> <span class="o">=</span> <span class="n">CreateBinTree</span><span class="p">();</span>
        <span class="n">T</span><span class="o">-&gt;</span><span class="n">rightChild</span> <span class="o">=</span> <span class="n">CreateBinTree</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">T</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 前序遍历</span>
<span class="kt">void</span> <span class="nf">PreTravel</span><span class="p">(</span><span class="n">BinTree</span><span class="o">*</span> <span class="n">tree</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
        <span class="n">PreTravel</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">leftChild</span><span class="p">);</span>
        <span class="n">PreTravel</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">rightChild</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 中序遍历</span>
<span class="kt">void</span> <span class="nf">InTravel</span><span class="p">(</span><span class="n">BinTree</span><span class="o">*</span> <span class="n">tree</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">InTravel</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">leftChild</span><span class="p">);</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
        <span class="n">InTravel</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">rightChild</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 后序遍历</span>
<span class="kt">void</span> <span class="nf">PostTravel</span><span class="p">(</span><span class="n">BinTree</span><span class="o">*</span> <span class="n">tree</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">PostTravel</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">leftChild</span><span class="p">);</span>
        <span class="n">PostTravel</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">rightChild</span><span class="p">);</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 层序遍历</span>
<span class="kt">void</span> <span class="nf">LevelTravel</span><span class="p">(</span><span class="n">BinTree</span><span class="o">*</span> <span class="n">tree</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="n">BinTree</span><span class="o">*&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tree</span><span class="p">);</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="c1">// cout &lt;&lt; q.size() &lt;&lt;"&amp; "&lt;&lt;endl;</span>
        <span class="n">BinTree</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">leftChild</span><span class="p">)</span> <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">leftChild</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">rightChild</span><span class="p">)</span> <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">rightChild</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 插入数--构建出的是搜索二叉树</span>
<span class="kt">void</span> <span class="nf">InsertTree</span><span class="p">(</span><span class="n">BinTree</span><span class="o">*</span> <span class="o">&amp;</span><span class="n">tree</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tree</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinTree</span><span class="p">();</span>
        <span class="n">tree</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&gt;</span><span class="n">data</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">InsertTree</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">leftChild</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">InsertTree</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">rightChild</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 查找树的最小值，树是中序排列</span>
<span class="kt">int</span> <span class="nf">finMin</span><span class="p">(</span><span class="n">BinTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tree</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">leftChild</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">return</span> <span class="n">finMin</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">leftChild</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 查找树的最大值</span>
<span class="kt">int</span> <span class="nf">finMax</span><span class="p">(</span><span class="n">BinTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tree</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">rightChild</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">return</span> <span class="n">finMax</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">rightChild</span><span class="p">);</span>
<span class="p">}</span>


<span class="c1">// 删除函数</span>
<span class="kt">void</span> <span class="nf">RemoveTree</span><span class="p">(</span><span class="n">BinTree</span><span class="o">*</span> <span class="o">&amp;</span><span class="n">tree</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tree</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> 
    <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">&lt;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="n">RemoveTree</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">leftChild</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">&gt;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>  <span class="n">RemoveTree</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">rightChild</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">leftChild</span> <span class="o">&amp;&amp;</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">rightChild</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">tree</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">finMin</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">rightChild</span><span class="p">);</span>
        <span class="n">RemoveTree</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">rightChild</span><span class="p">,</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span><span class="c1">// 回归</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="c1">// 左空，右上，否则，左上</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">leftChild</span><span class="p">)</span> <span class="o">?</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">leftChild</span> <span class="o">:</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">rightChild</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">BinTree</span> <span class="o">*</span><span class="n">tree</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="cm">/*cout &lt;&lt; "Please input a tree with PreOrder,use -1 as NULL" &lt;&lt; endl;
    tree = CreateBinTree();
    
    cout &lt;&lt; "PreOrder Traversal" &lt;&lt; endl;
    PreTravel(tree);
    cout &lt;&lt; " " &lt;&lt; endl;
    cout &lt;&lt; "InOrder Traversal" &lt;&lt; endl;
    InTravel(tree);
    cout &lt;&lt; " " &lt;&lt; endl;
    cout &lt;&lt; "PostOrder Traversal" &lt;&lt; endl;
    PostTravel(tree);
    cout &lt;&lt; " " &lt;&lt; endl;
    cout &lt;&lt; "LevelOrder Traversal" &lt;&lt; endl;
    LevelTravel(tree);
    cout &lt;&lt; " " &lt;&lt; endl;*/</span>

    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Input a node"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">InsertTree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"LevelOrder Traversal"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">LevelTravel</span><span class="p">(</span><span class="n">tree</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">RemoveTree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"LevelOrder Traversal"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">LevelTravel</span><span class="p">(</span><span class="n">tree</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/24/categories/c/'>C++</a>, <a href='/24/categories/test/'>Test</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/24/tags/c/" class="post-tag no-text-decoration" >c++</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Lead To Offer - Mat&url=https://i-mat.github.io/24/posts/lead-to-offer/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Lead To Offer - Mat&u=https://i-mat.github.io/24/posts/lead-to-offer/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Lead To Offer - Mat&url=https://i-mat.github.io/24/posts/lead-to-offer/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/24/posts/enable-google-pv/">Enable Google Page Views</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/24/tags/c/">c++</a> <a class="post-tag" href="/24/tags/chocolatey/">chocolatey</a> <a class="post-tag" href="/24/tags/deer/">deer</a> <a class="post-tag" href="/24/tags/favicon/">favicon</a> <a class="post-tag" href="/24/tags/find-job/">find job</a> <a class="post-tag" href="/24/tags/getting-started/">getting started</a> <a class="post-tag" href="/24/tags/google-analytics/">google analytics</a> <a class="post-tag" href="/24/tags/jekyll/">jekyll</a> <a class="post-tag" href="/24/tags/mask-rcnn/">Mask-RCNN</a> <a class="post-tag" href="/24/tags/pageviews/">pageviews</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/24/posts/cincout/"><div class="card-body"> <em class="timeago small" date="2019-08-20 11:33:00 +0800" >Aug 20, 2019</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Cin Cout</h3><div class="text-muted small"><p> 输入连续数进入vector 1 2 3 4 5 6 7 8 9 10 11 vector&amp;lt;int&amp;gt; a; int num,i=0; int temple; cin &amp;gt;&amp;gt; num; while (i&amp;lt;num) { cin &amp;gt;&amp;gt; temple; a.push_back(temple); i++; } 迭代器输出vector...</p></div></div></a></div><div class="card"> <a href="/24/posts/BinaryTree-Travel/"><div class="card-body"> <em class="timeago small" date="2019-08-24 11:33:00 +0800" >Aug 24, 2019</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>BinaryTree Travel</h3><div class="text-muted small"><p> 参考 遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void preorderTraversalNew(TreeNode *root, vector&amp;lt;int&amp;gt; &amp;amp;path) { stack&amp;lt; pair&amp;lt;TreeNode *, bool&amp;gt; &amp;gt; s; ...</p></div></div></a></div><div class="card"> <a href="/24/posts/BasicKnowldege/"><div class="card-body"> <em class="timeago small" date="2019-09-05 11:33:00 +0800" >Sep 5, 2019</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Basic Knowledge</h3><div class="text-muted small"><p> C++特性 封装：隐藏实现细节，使得代码模块化 继承：使用现有类的所有功能，进行功能拓展。从一般到特殊的过程，称为“子类”和“父类”。 多态：将父对象设置成为和一个或多个他的子对象相等的技术。允许将子类类型的指针赋值给父类类型的指针。将父类暴露给用户子类隐藏，子类指针转化成父类指针进行返回，可实现程序的简易替换，背后的运作原理通过子类进行切换。 上述特性最...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/24/posts/design-patterns/" class="btn btn-outline-primary" prompt="Older"><p>Design Patterns</p></a> <a href="/24/posts/cincout/" class="btn btn-outline-primary" prompt="Newer"><p>Cin Cout</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/i-mat">Sean Mat</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/24/tags/c/">c++</a> <a class="post-tag" href="/24/tags/chocolatey/">chocolatey</a> <a class="post-tag" href="/24/tags/deer/">deer</a> <a class="post-tag" href="/24/tags/favicon/">favicon</a> <a class="post-tag" href="/24/tags/find-job/">find job</a> <a class="post-tag" href="/24/tags/getting-started/">getting started</a> <a class="post-tag" href="/24/tags/google-analytics/">google analytics</a> <a class="post-tag" href="/24/tags/jekyll/">jekyll</a> <a class="post-tag" href="/24/tags/mask-rcnn/">Mask-RCNN</a> <a class="post-tag" href="/24/tags/pageviews/">pageviews</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[mode=dark]").length > 0 || ($("html[mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/24/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/24/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/24/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
